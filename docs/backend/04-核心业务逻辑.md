# 智慧餐厅系统 - 核心业务逻辑实现

## 1. 业务逻辑架构

### 1.1 设计原则
- 业务逻辑与视图层分离，使用Service层处理复杂业务
- 事务一致性保证数据完整性
- 缓存策略提升查询性能
- 异步任务处理耗时操作

### 1.2 业务模块划分
- 用户管理业务（UserService）
- 菜品管理业务（DishService）
- 订单管理业务（OrderService）
- 支付业务（PaymentService）
- 优惠券业务（CouponService）
- 库存管理业务（InventoryService）

## 2. 用户管理业务逻辑

### 2.1 用户服务类扩展
**apps/users/services.py**（扩展之前的认证服务）：
```python
from django.contrib.auth import get_user_model
from django.db import transaction
from django.core.cache import cache
from django.utils import timezone
from django.db.models import Q, Count
from apps.common.wechat import WeChatMiniProgramService
from apps.common.jwt_utils import generate_jwt_token
import logging

User = get_user_model()
logger = logging.getLogger(__name__)

class UserService:
    """用户业务服务类"""
    
    def __init__(self):
        self.wechat_service = WeChatMiniProgramService()
    
    def get_user_profile(self, user):
        """获取用户详细信息"""
        from apps.orders.models import Order
        
        # 缓存键
        cache_key = f"user_profile:{user.id}"
        profile_data = cache.get(cache_key)
        
        if profile_data:
            return profile_data
        
        # 统计用户数据
        order_stats = Order.objects.filter(user=user).aggregate(
            total_orders=Count('id'),
            completed_orders=Count('id', filter=Q(status='completed'))
        )
        
        profile_data = {
            'user_info': {
                'id': user.id,
                'nickname': user.nickname,
                'avatar_url': user.avatar_url,
                'phone': user.phone,
                'gender': user.gender,
                'is_admin': user.is_admin,
                'created_time': user.created_time,
                'last_login_time': user.last_login_time,
            },
            'statistics': {
                'total_orders': order_stats['total_orders'] or 0,
                'completed_orders': order_stats['completed_orders'] or 0,
                'member_days': (timezone.now().date() - user.created_time.date()).days,
            }
        }
        
        # 缓存30分钟
        cache.set(cache_key, profile_data, 1800)
        return profile_data
    
    def update_user_profile(self, user, update_data):
        """更新用户信息"""
        allowed_fields = ['nickname', 'phone', 'gender']
        
        with transaction.atomic():
            for field, value in update_data.items():
                if field in allowed_fields:
                    setattr(user, field, value)
            
            user.save(update_fields=allowed_fields)
            
            # 清除缓存
            cache.delete(f"user_profile:{user.id}")
        
        return user
    
    def set_admin_status(self, user, is_admin, operator_user):
        """设置用户管理员状态"""
        if not operator_user.is_admin:
            raise PermissionError("只有管理员可以设置管理员权限")
        
        if user.id == operator_user.id:
            raise ValueError("不能修改自己的管理员状态")
        
        user.is_admin = is_admin
        user.save(update_fields=['is_admin'])
        
        logger.info(f"管理员{operator_user.nickname}将用户{user.nickname}的管理员状态设置为{is_admin}")
        return user
    
    def get_user_list(self, page=1, page_size=20, search=None, is_admin=None):
        """获取用户列表（管理员功能）"""
        queryset = User.objects.all()
        
        # 搜索过滤
        if search:
            queryset = queryset.filter(
                Q(nickname__icontains=search) | 
                Q(phone__icontains=search)
            )
        
        # 管理员状态过滤
        if is_admin is not None:
            queryset = queryset.filter(is_admin=is_admin)
        
        # 排序
        queryset = queryset.order_by('-created_time')
        
        # 分页
        offset = (page - 1) * page_size
        users = queryset[offset:offset + page_size]
        total = queryset.count()
        
        return {
            'users': users,
            'total': total,
            'page': page,
            'page_size': page_size,
            'total_pages': (total + page_size - 1) // page_size
        }
```

## 3. 菜品管理业务逻辑

### 3.1 菜品服务类
**apps/dishes/services.py**：
```python
from django.db import transaction
from django.core.cache import cache
from django.db.models import Q, Count, Avg
from apps.dishes.models import Category, Dish
from apps.reviews.models import Review
import logging

logger = logging.getLogger(__name__)

class DishService:
    """菜品业务服务类"""
    
    def get_categories_with_dishes(self):
        """获取分类及其菜品列表"""
        cache_key = "categories_with_dishes"
        data = cache.get(cache_key)
        
        if data:
            return data
        
        categories = Category.objects.filter(is_active=True).prefetch_related(
            'dishes'
        ).order_by('-sort_order')
        
        result = []
        for category in categories:
            active_dishes = category.dishes.filter(is_active=True).order_by('-sort_order', '-sales_count')
            if active_dishes.exists():
                result.append({
                    'category': category,
                    'dishes': active_dishes
                })
        
        # 缓存15分钟
        cache.set(cache_key, result, 900)
        return result
    
    def get_dish_detail(self, dish_id):
        """获取菜品详情"""
        cache_key = f"dish_detail:{dish_id}"
        data = cache.get(cache_key)
        
        if data:
            return data
        
        try:
            dish = Dish.objects.select_related('category').get(
                id=dish_id, 
                is_active=True
            )
            
            # 获取评价统计
            review_stats = Review.objects.filter(
                dish=dish, 
                is_visible=True
            ).aggregate(
                avg_rating=Avg('rating'),
                total_reviews=Count('id')
            )
            
            data = {
                'dish': dish,
                'avg_rating': round(review_stats['avg_rating'] or 0, 1),
                'total_reviews': review_stats['total_reviews'] or 0
            }
            
            # 缓存10分钟
            cache.set(cache_key, data, 600)
            return data
            
        except Dish.DoesNotExist:
            return None
    
    def search_dishes(self, keyword, category_id=None, page=1, page_size=20):
        """搜索菜品"""
        queryset = Dish.objects.filter(is_active=True)
        
        if keyword:
            queryset = queryset.filter(
                Q(name__icontains=keyword) | 
                Q(description__icontains=keyword) |
                Q(tags__icontains=keyword)
            )
        
        if category_id:
            queryset = queryset.filter(category_id=category_id)
        
        queryset = queryset.select_related('category').order_by('-sales_count', '-sort_order')
        
        # 分页
        offset = (page - 1) * page_size
        dishes = queryset[offset:offset + page_size]
        total = queryset.count()
        
        return {
            'dishes': dishes,
            'total': total,
            'page': page,
            'page_size': page_size,
            'total_pages': (total + page_size - 1) // page_size
        }
    
    def get_recommended_dishes(self, limit=10):
        """获取推荐菜品"""
        cache_key = f"recommended_dishes:{limit}"
        dishes = cache.get(cache_key)
        
        if dishes:
            return dishes
        
        dishes = Dish.objects.filter(
            is_active=True,
            is_recommended=True
        ).select_related('category').order_by('-sort_order', '-sales_count')[:limit]
        
        # 缓存20分钟
        cache.set(cache_key, dishes, 1200)
        return dishes
    
    @transaction.atomic
    def create_dish(self, dish_data, operator_user):
        """创建菜品"""
        if not operator_user.is_admin:
            raise PermissionError("只有管理员可以创建菜品")
        
        dish = Dish.objects.create(**dish_data)
        
        # 清除相关缓存
        self._clear_dish_cache()
        
        logger.info(f"管理员{operator_user.nickname}创建菜品: {dish.name}")
        return dish
    
    @transaction.atomic
    def update_dish(self, dish, update_data, operator_user):
        """更新菜品"""
        if not operator_user.is_admin:
            raise PermissionError("只有管理员可以修改菜品")
        
        for field, value in update_data.items():
            setattr(dish, field, value)
        
        dish.save()
        
        # 清除相关缓存
        self._clear_dish_cache()
        cache.delete(f"dish_detail:{dish.id}")
        
        logger.info(f"管理员{operator_user.nickname}更新菜品: {dish.name}")
        return dish
    
    @transaction.atomic
    def delete_dish(self, dish, operator_user):
        """删除菜品"""
        if not operator_user.is_admin:
            raise PermissionError("只有管理员可以删除菜品")
        
        dish.is_active = False
        dish.save(update_fields=['is_active'])
        
        # 清除相关缓存
        self._clear_dish_cache()
        cache.delete(f"dish_detail:{dish.id}")
        
        logger.info(f"管理员{operator_user.nickname}删除菜品: {dish.name}")
        return dish
    
    def _clear_dish_cache(self):
        """清除菜品相关缓存"""
        cache.delete("categories_with_dishes")
        cache.delete_pattern("recommended_dishes:*")

class CategoryService:
    """分类业务服务类"""
    
    @transaction.atomic
    def create_category(self, category_data, operator_user):
        """创建分类"""
        if not operator_user.is_admin:
            raise PermissionError("只有管理员可以创建分类")
        
        category = Category.objects.create(**category_data)
        
        # 清除缓存
        cache.delete("categories_with_dishes")
        
        logger.info(f"管理员{operator_user.nickname}创建分类: {category.name}")
        return category
    
    @transaction.atomic
    def update_category(self, category, update_data, operator_user):
        """更新分类"""
        if not operator_user.is_admin:
            raise PermissionError("只有管理员可以修改分类")
        
        for field, value in update_data.items():
            setattr(category, field, value)
        
        category.save()
        
        # 清除缓存
        cache.delete("categories_with_dishes")
        
        logger.info(f"管理员{operator_user.nickname}更新分类: {category.name}")
        return category
```

## 4. 订单管理业务逻辑

### 4.1 订单服务类
**apps/orders/services.py**：
```python
from django.db import transaction, models
from django.core.cache import cache
from django.utils import timezone
from apps.orders.models import Order, OrderItem
from apps.dishes.models import Dish
from apps.coupons.services import CouponService
from decimal import Decimal
import logging

logger = logging.getLogger(__name__)

class OrderService:
    """订单业务服务类"""
    
    def __init__(self):
        self.coupon_service = CouponService()
    
    @transaction.atomic
    def create_order(self, user, order_data):
        """创建订单"""
        cart_items = order_data.get('cart_items', [])
        table_number = order_data.get('table_number')
        customer_notes = order_data.get('customer_notes', '')
        coupon_code = order_data.get('coupon_code')
        
        if not cart_items:
            raise ValueError("购物车不能为空")
        
        # 1. 验证菜品库存和状态
        dish_data = self._validate_cart_items(cart_items)
        
        # 2. 计算订单金额
        total_amount = sum(item['subtotal'] for item in dish_data)
        
        # 3. 应用优惠券
        discount_amount = Decimal('0.00')
        coupon = None
        if coupon_code:
            coupon, discount_amount = self._apply_coupon(user, coupon_code, total_amount)
        
        final_amount = total_amount - discount_amount
        
        # 4. 创建订单
        order = Order.objects.create(
            user=user,
            total_amount=total_amount,
            discount_amount=discount_amount,
            final_amount=final_amount,
            table_number=table_number,
            customer_notes=customer_notes,
            coupon=coupon
        )
        
        # 5. 创建订单项
        order_items = []
        for item_data in dish_data:
            order_item = OrderItem(
                order=order,
                dish=item_data['dish'],
                quantity=item_data['quantity'],
                special_requests=item_data.get('special_requests', '')
            )
            order_items.append(order_item)
        
        OrderItem.objects.bulk_create(order_items)
        
        # 6. 减少库存
        for item_data in dish_data:
            item_data['dish'].decrease_stock(item_data['quantity'])
        
        # 7. 标记优惠券为已使用
        if coupon:
            self.coupon_service.use_coupon(user, coupon, order)
        
        logger.info(f"用户{user.nickname}创建订单{order.order_no}, 金额{final_amount}")
        return order
    
    def _validate_cart_items(self, cart_items):
        """验证购物车商品"""
        dish_data = []
        
        for item in cart_items:
            dish_id = item.get('dish_id')
            quantity = item.get('quantity', 1)
            
            try:
                dish = Dish.objects.get(id=dish_id, is_active=True)
            except Dish.DoesNotExist:
                raise ValueError(f"菜品{dish_id}不存在或已下架")
            
            if not dish.is_in_stock():
                raise ValueError(f"菜品{dish.name}暂时缺货")
            
            if dish.stock_quantity != -1 and dish.stock_quantity < quantity:
                raise ValueError(f"菜品{dish.name}库存不足，仅剩{dish.stock_quantity}份")
            
            subtotal = dish.price * quantity
            dish_data.append({
                'dish': dish,
                'quantity': quantity,
                'subtotal': subtotal,
                'special_requests': item.get('special_requests', '')
            })
        
        return dish_data
    
    def _apply_coupon(self, user, coupon_code, total_amount):
        """应用优惠券"""
        coupon = self.coupon_service.validate_coupon(user, coupon_code)
        discount_amount = coupon.calculate_discount(total_amount)
        
        return coupon, Decimal(str(discount_amount))
    
    def get_user_orders(self, user, status=None, page=1, page_size=20):
        """获取用户订单列表"""
        queryset = Order.objects.filter(user=user)
        
        if status:
            queryset = queryset.filter(status=status)
        
        queryset = queryset.prefetch_related('items__dish').order_by('-created_time')
        
        # 分页
        offset = (page - 1) * page_size
        orders = queryset[offset:offset + page_size]
        total = queryset.count()
        
        return {
            'orders': orders,
            'total': total,
            'page': page,
            'page_size': page_size,
            'total_pages': (total + page_size - 1) // page_size
        }
    
    def get_order_detail(self, order_id, user=None):
        """获取订单详情"""
        try:
            queryset = Order.objects.prefetch_related('items__dish', 'payments')
            
            if user and not user.is_admin:
                # 普通用户只能查看自己的订单
                order = queryset.get(id=order_id, user=user)
            else:
                # 管理员可以查看所有订单
                order = queryset.get(id=order_id)
            
            return order
        except Order.DoesNotExist:
            return None
    
    @transaction.atomic
    def update_order_status(self, order, new_status, operator_user, notes=None):
        """更新订单状态"""
        valid_transitions = {
            'pending_payment': ['paid', 'cancelled'],
            'paid': ['preparing', 'cancelled'],
            'preparing': ['ready'],
            'ready': ['completed'],
        }
        
        if new_status not in valid_transitions.get(order.status, []):
            raise ValueError(f"订单状态不能从{order.status}变更为{new_status}")
        
        old_status = order.status
        order.status = new_status
        
        if notes:
            order.admin_notes = notes
        
        # 设置时间戳
        if new_status == 'completed':
            order.completed_time = timezone.now()
        elif new_status == 'cancelled':
            order.cancelled_time = timezone.now()
        
        order.save()
        
        logger.info(f"操作员{operator_user.nickname}将订单{order.order_no}状态从{old_status}更新为{new_status}")
        return order
    
    @transaction.atomic
    def cancel_order(self, order, user, reason=None):
        """取消订单"""
        if not order.can_cancel():
            raise ValueError("当前状态的订单不能取消")
        
        if order.user != user and not user.is_admin:
            raise PermissionError("只能取消自己的订单")
        
        order.status = 'cancelled'
        order.cancelled_time = timezone.now()
        if reason:
            order.customer_notes = f"{order.customer_notes}\n取消原因: {reason}" if order.customer_notes else f"取消原因: {reason}"
        
        order.save()
        
        # 恢复库存
        for item in order.items.all():
            if item.dish.stock_quantity != -1:
                item.dish.stock_quantity += item.quantity
                item.dish.save(update_fields=['stock_quantity'])
        
        # 恢复优惠券
        if order.coupon:
            self.coupon_service.restore_coupon(order.user, order.coupon)
        
        logger.info(f"用户{user.nickname}取消订单{order.order_no}")
        return order
    
    def get_admin_orders(self, status=None, date_range=None, page=1, page_size=20):
        """管理员获取订单列表"""
        queryset = Order.objects.select_related('user').prefetch_related('items')
        
        if status:
            queryset = queryset.filter(status=status)
        
        if date_range:
            start_date, end_date = date_range
            queryset = queryset.filter(created_time__range=[start_date, end_date])
        
        queryset = queryset.order_by('-created_time')
        
        # 分页
        offset = (page - 1) * page_size
        orders = queryset[offset:offset + page_size]
        total = queryset.count()
        
        return {
            'orders': orders,
            'total': total,
            'page': page,
            'page_size': page_size,
            'total_pages': (total + page_size - 1) // page_size
        }
    
    def get_order_statistics(self, date_range=None):
        """获取订单统计"""
        queryset = Order.objects.all()
        
        if date_range:
            start_date, end_date = date_range
            queryset = queryset.filter(created_time__range=[start_date, end_date])
        
        stats = queryset.aggregate(
            total_orders=models.Count('id'),
            total_amount=models.Sum('final_amount'),
            avg_amount=models.Avg('final_amount'),
            pending_orders=models.Count('id', filter=models.Q(status='pending_payment')),
            completed_orders=models.Count('id', filter=models.Q(status='completed')),
            cancelled_orders=models.Count('id', filter=models.Q(status='cancelled'))
        )
        
        return stats
```

## 5. 优惠券业务逻辑

### 5.1 优惠券服务类
**apps/coupons/services.py**：
```python
from django.db import transaction
from django.utils import timezone
from django.core.cache import cache
from apps.coupons.models import Coupon, UserCoupon
import logging

logger = logging.getLogger(__name__)

class CouponService:
    """优惠券业务服务类"""
    
    def validate_coupon(self, user, coupon_code):
        """验证优惠券"""
        try:
            coupon = Coupon.objects.get(code=coupon_code, is_active=True)
        except Coupon.DoesNotExist:
            raise ValueError("优惠券不存在或已失效")
        
        if not coupon.is_valid():
            raise ValueError("优惠券已过期或使用完毕")
        
        # 检查用户是否已领取该优惠券
        user_coupon = UserCoupon.objects.filter(
            user=user, 
            coupon=coupon, 
            status='unused'
        ).first()
        
        if not user_coupon:
            raise ValueError("您还未领取该优惠券或已使用")
        
        return coupon
    
    @transaction.atomic
    def use_coupon(self, user, coupon, order):
        """使用优惠券"""
        user_coupon = UserCoupon.objects.select_for_update().get(
            user=user,
            coupon=coupon,
            status='unused'
        )
        
        user_coupon.status = 'used'
        user_coupon.order = order
        user_coupon.used_time = timezone.now()
        user_coupon.save()
        
        # 更新优惠券使用数量
        coupon.used_quantity = models.F('used_quantity') + 1
        coupon.save(update_fields=['used_quantity'])
        
        logger.info(f"用户{user.nickname}使用优惠券{coupon.code}")
    
    @transaction.atomic
    def restore_coupon(self, user, coupon):
        """恢复优惠券（取消订单时）"""
        user_coupon = UserCoupon.objects.filter(
            user=user,
            coupon=coupon,
            status='used'
        ).first()
        
        if user_coupon:
            user_coupon.status = 'unused'
            user_coupon.order = None
            user_coupon.used_time = None
            user_coupon.save()
            
            # 更新优惠券使用数量
            coupon.used_quantity = models.F('used_quantity') - 1
            coupon.save(update_fields=['used_quantity'])
            
            logger.info(f"用户{user.nickname}的优惠券{coupon.code}已恢复")
    
    @transaction.atomic
    def claim_coupon(self, user, coupon_code):
        """领取优惠券"""
        try:
            coupon = Coupon.objects.select_for_update().get(
                code=coupon_code, 
                is_active=True
            )
        except Coupon.DoesNotExist:
            raise ValueError("优惠券不存在")
        
        if not coupon.is_valid():
            raise ValueError("优惠券已过期或领完")
        
        # 检查用户是否已领取
        if UserCoupon.objects.filter(user=user, coupon=coupon).exists():
            raise ValueError("您已经领取过该优惠券")
        
        # 检查领取限制
        user_coupon_count = UserCoupon.objects.filter(
            user=user, 
            coupon=coupon
        ).count()
        
        if user_coupon_count >= coupon.per_user_limit:
            raise ValueError("已达到该优惠券的领取上限")
        
        # 创建用户优惠券记录
        UserCoupon.objects.create(
            user=user,
            coupon=coupon
        )
        
        logger.info(f"用户{user.nickname}领取优惠券{coupon.code}")
        return coupon
    
    def get_user_coupons(self, user, status=None):
        """获取用户优惠券列表"""
        queryset = UserCoupon.objects.filter(user=user).select_related('coupon')
        
        if status:
            queryset = queryset.filter(status=status)
        
        return queryset.order_by('-received_time')
    
    def get_available_coupons(self, user):
        """获取用户可用的优惠券"""
        # 获取用户已领取的优惠券ID
        claimed_coupon_ids = UserCoupon.objects.filter(user=user).values_list('coupon_id', flat=True)
        
        # 获取可领取的优惠券
        available_coupons = Coupon.objects.filter(
            is_active=True,
            start_time__lte=timezone.now(),
            end_time__gte=timezone.now()
        ).exclude(id__in=claimed_coupon_ids)
        
        return available_coupons.order_by('-created_time')
```

## 6. 库存管理业务逻辑

### 6.1 库存服务类
**apps/common/inventory.py**：
```python
from django.db import transaction
from django.core.cache import cache
from apps.dishes.models import Dish
import logging

logger = logging.getLogger(__name__)

class InventoryService:
    """库存管理服务类"""
    
    @transaction.atomic
    def check_and_reserve_stock(self, cart_items):
        """检查并预留库存"""
        reservations = []
        
        try:
            for item in cart_items:
                dish = Dish.objects.select_for_update().get(
                    id=item['dish_id'], 
                    is_active=True
                )
                
                quantity = item['quantity']
                
                if dish.stock_quantity == -1:
                    # 无限库存
                    reservations.append({
                        'dish': dish,
                        'quantity': quantity,
                        'reserved': True
                    })
                elif dish.stock_quantity >= quantity:
                    # 有足够库存
                    dish.stock_quantity -= quantity
                    dish.save(update_fields=['stock_quantity'])
                    
                    reservations.append({
                        'dish': dish,
                        'quantity': quantity,
                        'reserved': True
                    })
                else:
                    raise ValueError(f"菜品{dish.name}库存不足")
            
            return reservations
            
        except Exception as e:
            # 发生异常时恢复已预留的库存
            self._restore_reservations(reservations)
            raise e
    
    def _restore_reservations(self, reservations):
        """恢复预留的库存"""
        for reservation in reservations:
            if reservation['reserved']:
                dish = reservation['dish']
                if dish.stock_quantity != -1:
                    dish.stock_quantity += reservation['quantity']
                    dish.save(update_fields=['stock_quantity'])
    
    def get_low_stock_dishes(self, threshold=10):
        """获取低库存菜品"""
        return Dish.objects.filter(
            is_active=True,
            stock_quantity__lte=threshold,
            stock_quantity__gt=0
        ).select_related('category')
    
    @transaction.atomic
    def update_dish_stock(self, dish_id, new_stock, operator_user):
        """更新菜品库存"""
        if not operator_user.is_admin:
            raise PermissionError("只有管理员可以修改库存")
        
        try:
            dish = Dish.objects.get(id=dish_id)
            old_stock = dish.stock_quantity
            dish.stock_quantity = new_stock
            dish.save(update_fields=['stock_quantity'])
            
            logger.info(f"管理员{operator_user.nickname}将菜品{dish.name}库存从{old_stock}调整为{new_stock}")
            return dish
            
        except Dish.DoesNotExist:
            raise ValueError("菜品不存在")
    
    def get_stock_statistics(self):
        """获取库存统计"""
        from django.db.models import Count, Q
        
        stats = Dish.objects.filter(is_active=True).aggregate(
            total_dishes=Count('id'),
            unlimited_stock=Count('id', filter=Q(stock_quantity=-1)),
            zero_stock=Count('id', filter=Q(stock_quantity=0)),
            low_stock=Count('id', filter=Q(stock_quantity__lte=10, stock_quantity__gt=0)),
        )
        
        return stats
```

## 7. 业务事件通知

### 7.1 事件通知服务
**apps/common/notifications.py**：
```python
from django.core.mail import send_mail
from django.conf import settings
import logging

logger = logging.getLogger(__name__)

class NotificationService:
    """通知服务类"""
    
    def send_order_notification(self, order, event_type):
        """发送订单通知"""
        try:
            if event_type == 'created':
                self._notify_order_created(order)
            elif event_type == 'paid':
                self._notify_order_paid(order)
            elif event_type == 'completed':
                self._notify_order_completed(order)
            elif event_type == 'cancelled':
                self._notify_order_cancelled(order)
                
        except Exception as e:
            logger.error(f"发送订单通知失败: {e}")
    
    def _notify_order_created(self, order):
        """通知订单创建"""
        message = f"新订单: {order.order_no}, 金额: ¥{order.final_amount}"
        logger.info(message)
        # 这里可以集成短信、邮件、WebSocket等通知方式
    
    def _notify_order_paid(self, order):
        """通知订单支付完成"""
        message = f"订单支付完成: {order.order_no}, 金额: ¥{order.final_amount}"
        logger.info(message)
    
    def _notify_order_completed(self, order):
        """通知订单完成"""
        message = f"订单完成: {order.order_no}"
        logger.info(message)
    
    def _notify_order_cancelled(self, order):
        """通知订单取消"""
        message = f"订单取消: {order.order_no}"
        logger.info(message)
    
    def send_low_stock_alert(self, dishes):
        """发送低库存警告"""
        if not dishes:
            return
        
        dish_names = [dish.name for dish in dishes]
        message = f"以下菜品库存不足: {', '.join(dish_names)}"
        logger.warning(message)
        
        # 发送给管理员
        # send_mail(
        #     subject='库存不足警告',
        #     message=message,
        #     from_email=settings.DEFAULT_FROM_EMAIL,
        #     recipient_list=['admin@restaurant.com']
        # )
```

## 8. 定时任务

### 8.1 定时任务示例
**apps/common/tasks.py**：
```python
from celery import shared_task
from django.utils import timezone
from apps.orders.models import Order
from apps.coupons.models import UserCoupon
from apps.common.inventory import InventoryService
from apps.common.notifications import NotificationService
import logging

logger = logging.getLogger(__name__)

@shared_task
def cancel_expired_orders():
    """取消过期未支付订单"""
    # 查找超过30分钟未支付的订单
    expired_time = timezone.now() - timezone.timedelta(minutes=30)
    expired_orders = Order.objects.filter(
        status='pending_payment',
        created_time__lt=expired_time
    )
    
    count = 0
    for order in expired_orders:
        order.status = 'cancelled'
        order.cancelled_time = timezone.now()
        order.save()
        
        # 恢复库存
        for item in order.items.all():
            if item.dish.stock_quantity != -1:
                item.dish.stock_quantity += item.quantity
                item.dish.save(update_fields=['stock_quantity'])
        
        count += 1
    
    logger.info(f"自动取消{count}个过期订单")
    return count

@shared_task
def expire_coupons():
    """标记过期优惠券"""
    expired_coupons = UserCoupon.objects.filter(
        status='unused',
        coupon__end_time__lt=timezone.now()
    )
    
    count = expired_coupons.update(status='expired')
    logger.info(f"标记{count}张优惠券为过期")
    return count

@shared_task
def check_low_stock():
    """检查低库存并发送通知"""
    inventory_service = InventoryService()
    notification_service = NotificationService()
    
    low_stock_dishes = inventory_service.get_low_stock_dishes()
    if low_stock_dishes:
        notification_service.send_low_stock_alert(low_stock_dishes)
    
    return len(low_stock_dishes)
```

核心业务逻辑的实现确保了系统的可靠性和数据一致性，为API接口层提供了坚实的基础。 