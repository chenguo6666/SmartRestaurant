# 智慧餐厅系统 - 测试与部署

## 1. 测试策略概述

### 1.1 测试金字塔
- **单元测试（Unit Tests）**：测试单个函数和方法
- **集成测试（Integration Tests）**：测试模块间交互
- **API测试（API Tests）**：测试API接口
- **端到端测试（E2E Tests）**：测试完整业务流程

### 1.2 测试工具选择
- **Django TestCase**：Django内置测试框架
- **pytest**：更强大的Python测试框架
- **Factory Boy**：测试数据生成
- **Mock**：模拟外部依赖
- **Coverage**：代码覆盖率

## 2. 测试环境配置

### 2.1 测试设置文件
**smart_restaurant/settings/testing.py**：
```python
from .base import *

# 测试数据库配置
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': ':memory:',
    }
}

# 禁用缓存
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
    }
}

# 禁用迁移加速测试
class DisableMigrations:
    def __contains__(self, item):
        return True
    
    def __getitem__(self, item):
        return None

MIGRATION_MODULES = DisableMigrations()

# 关闭调试
DEBUG = False

# 日志配置（测试环境简化）
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'WARNING',
    },
}

# 测试密钥
SECRET_KEY = 'test-secret-key'

# 密码验证（测试环境简化）
AUTH_PASSWORD_VALIDATORS = []

# 禁用CSRF（测试环境）
CSRF_COOKIE_SECURE = False
SESSION_COOKIE_SECURE = False

# 邮件后端（测试环境）
EMAIL_BACKEND = 'django.core.mail.backends.locmem.EmailBackend'

# Celery配置（测试环境同步执行）
CELERY_TASK_ALWAYS_EAGER = True
CELERY_TASK_EAGER_PROPAGATES = True
```

### 2.2 pytest配置
**pytest.ini**：
```ini
[tool:pytest]
DJANGO_SETTINGS_MODULE = smart_restaurant.settings.testing
python_files = tests.py test_*.py *_tests.py
addopts = 
    --verbose
    --tb=short
    --strict-markers
    --disable-warnings
    --cov=apps
    --cov-report=term-missing
    --cov-report=html
    --cov-fail-under=80
markers =
    unit: Unit tests
    integration: Integration tests
    api: API tests
    slow: Slow running tests
```

### 2.3 依赖安装
**requirements/test.txt**：
```txt
pytest==7.4.3
pytest-django==4.6.0
pytest-cov==4.1.0
pytest-mock==3.12.0
factory-boy==3.3.0
faker==19.12.0
freezegun==1.2.2
responses==0.24.1
```

## 3. 测试数据工厂

### 3.1 用户数据工厂
**tests/factories.py**：
```python
import factory
from django.contrib.auth import get_user_model
from apps.dishes.models import Category, Dish
from apps.orders.models import Order, OrderItem
from apps.coupons.models import Coupon
from faker import Faker

User = get_user_model()
fake = Faker('zh_CN')

class UserFactory(factory.django.DjangoModelFactory):
    """用户工厂"""
    class Meta:
        model = User
    
    username = factory.Sequence(lambda n: f"user{n}")
    openid = factory.LazyAttribute(lambda obj: f"openid_{obj.username}")
    nickname = factory.LazyFunction(fake.name)
    phone = factory.LazyFunction(lambda: fake.phone_number())
    email = factory.LazyAttribute(lambda obj: f"{obj.username}@example.com")
    is_active = True
    is_admin = False

class AdminUserFactory(UserFactory):
    """管理员用户工厂"""
    is_admin = True
    is_staff = True

class CategoryFactory(factory.django.DjangoModelFactory):
    """分类工厂"""
    class Meta:
        model = Category
    
    name = factory.LazyFunction(lambda: fake.word())
    description = factory.LazyFunction(fake.text)
    sort_order = factory.Sequence(lambda n: n * 10)
    is_active = True

class DishFactory(factory.django.DjangoModelFactory):
    """菜品工厂"""
    class Meta:
        model = Dish
    
    category = factory.SubFactory(CategoryFactory)
    name = factory.LazyFunction(lambda: f"{fake.word()}菜")
    description = factory.LazyFunction(fake.text)
    price = factory.LazyFunction(lambda: fake.pydecimal(left_digits=2, right_digits=2, positive=True))
    stock_quantity = factory.LazyFunction(lambda: fake.random_int(min=0, max=100))
    is_active = True
    is_recommended = factory.LazyFunction(fake.boolean)

class OrderFactory(factory.django.DjangoModelFactory):
    """订单工厂"""
    class Meta:
        model = Order
    
    user = factory.SubFactory(UserFactory)
    total_amount = factory.LazyFunction(lambda: fake.pydecimal(left_digits=3, right_digits=2, positive=True))
    discount_amount = factory.LazyAttribute(lambda obj: obj.total_amount * fake.pydecimal(left_digits=0, right_digits=2, positive=True, max_value=0.3))
    final_amount = factory.LazyAttribute(lambda obj: obj.total_amount - obj.discount_amount)
    status = 'pending_payment'
    table_number = factory.LazyFunction(lambda: f"A{fake.random_int(min=1, max=50):02d}")

class OrderItemFactory(factory.django.DjangoModelFactory):
    """订单项工厂"""
    class Meta:
        model = OrderItem
    
    order = factory.SubFactory(OrderFactory)
    dish = factory.SubFactory(DishFactory)
    quantity = factory.LazyFunction(lambda: fake.random_int(min=1, max=5))
    dish_name = factory.LazyAttribute(lambda obj: obj.dish.name)
    dish_price = factory.LazyAttribute(lambda obj: obj.dish.price)
    subtotal = factory.LazyAttribute(lambda obj: obj.dish_price * obj.quantity)

class CouponFactory(factory.django.DjangoModelFactory):
    """优惠券工厂"""
    class Meta:
        model = Coupon
    
    name = factory.LazyFunction(lambda: f"{fake.word()}优惠券")
    code = factory.Sequence(lambda n: f"COUPON{n:04d}")
    type = 'fixed_amount'
    discount_value = factory.LazyFunction(lambda: fake.pydecimal(left_digits=2, right_digits=2, positive=True))
    total_quantity = factory.LazyFunction(lambda: fake.random_int(min=10, max=1000))
    start_time = factory.LazyFunction(fake.past_datetime)
    end_time = factory.LazyFunction(fake.future_datetime)
    is_active = True
```

## 4. 单元测试

### 4.1 模型测试
**tests/test_models.py**：
```python
import pytest
from decimal import Decimal
from django.core.exceptions import ValidationError
from django.db import IntegrityError
from apps.dishes.models import Dish, Category
from apps.orders.models import Order, OrderItem
from tests.factories import UserFactory, CategoryFactory, DishFactory, OrderFactory

@pytest.mark.django_db
class TestDishModel:
    """菜品模型测试"""
    
    def test_dish_creation(self):
        """测试菜品创建"""
        dish = DishFactory()
        assert dish.id is not None
        assert dish.name
        assert dish.price > 0
        assert dish.category is not None
    
    def test_dish_str_method(self):
        """测试菜品字符串表示"""
        dish = DishFactory(name="宫保鸡丁", price=Decimal('25.00'))
        expected = "宫保鸡丁 - ¥25.00"
        assert str(dish) == expected
    
    def test_get_display_price(self):
        """测试价格显示方法"""
        # 无原价
        dish = DishFactory(price=Decimal('25.00'), original_price=None)
        assert dish.get_display_price() == "¥25.00"
        
        # 有原价
        dish = DishFactory(price=Decimal('20.00'), original_price=Decimal('25.00'))
        assert dish.get_display_price() == "¥20.00 (原价¥25.00)"
    
    def test_is_in_stock(self):
        """测试库存检查"""
        # 无限库存
        dish = DishFactory(stock_quantity=-1)
        assert dish.is_in_stock() is True
        
        # 有库存
        dish = DishFactory(stock_quantity=10)
        assert dish.is_in_stock() is True
        
        # 无库存
        dish = DishFactory(stock_quantity=0)
        assert dish.is_in_stock() is False
    
    def test_decrease_stock(self):
        """测试减少库存"""
        # 无限库存
        dish = DishFactory(stock_quantity=-1)
        result = dish.decrease_stock(5)
        assert result is True
        assert dish.stock_quantity == -1
        
        # 足够库存
        dish = DishFactory(stock_quantity=10)
        result = dish.decrease_stock(3)
        assert result is True
        assert dish.stock_quantity == 7
        
        # 库存不足
        dish = DishFactory(stock_quantity=2)
        result = dish.decrease_stock(5)
        assert result is False
        assert dish.stock_quantity == 2
    
    def test_increase_sales(self):
        """测试增加销量"""
        dish = DishFactory(sales_count=10)
        dish.increase_sales(5)
        assert dish.sales_count == 15

@pytest.mark.django_db
class TestOrderModel:
    """订单模型测试"""
    
    def test_order_creation(self):
        """测试订单创建"""
        order = OrderFactory()
        assert order.id is not None
        assert order.order_no
        assert order.user is not None
        assert order.final_amount >= 0
    
    def test_order_no_generation(self):
        """测试订单号生成"""
        order1 = OrderFactory()
        order2 = OrderFactory()
        assert order1.order_no != order2.order_no
        assert order1.order_no.startswith('SR')
    
    def test_can_cancel(self):
        """测试取消订单条件"""
        # 待支付订单可以取消
        order = OrderFactory(status='pending_payment')
        assert order.can_cancel() is True
        
        # 已支付订单可以取消
        order = OrderFactory(status='paid')
        assert order.can_cancel() is True
        
        # 制作中订单不能取消
        order = OrderFactory(status='preparing')
        assert order.can_cancel() is False
    
    def test_can_pay(self):
        """测试支付条件"""
        order = OrderFactory(status='pending_payment', payment_status='unpaid')
        assert order.can_pay() is True
        
        order = OrderFactory(status='paid', payment_status='paid')
        assert order.can_pay() is False
```

### 4.2 服务层测试
**tests/test_services.py**：
```python
import pytest
from unittest.mock import Mock, patch
from decimal import Decimal
from apps.dishes.services import DishService
from apps.orders.services import OrderService
from apps.users.services import UserService
from tests.factories import UserFactory, DishFactory, OrderFactory

@pytest.mark.django_db
class TestDishService:
    """菜品服务测试"""
    
    def setup_method(self):
        self.dish_service = DishService()
    
    def test_get_dish_detail_exists(self):
        """测试获取存在的菜品详情"""
        dish = DishFactory()
        result = self.dish_service.get_dish_detail(dish.id)
        
        assert result is not None
        assert result['dish'] == dish
        assert 'avg_rating' in result
        assert 'total_reviews' in result
    
    def test_get_dish_detail_not_exists(self):
        """测试获取不存在的菜品详情"""
        result = self.dish_service.get_dish_detail(99999)
        assert result is None
    
    @patch('apps.dishes.services.cache')
    def test_get_recommended_dishes_cached(self, mock_cache):
        """测试推荐菜品缓存"""
        dishes = [DishFactory(is_recommended=True) for _ in range(3)]
        mock_cache.get.return_value = dishes
        
        result = self.dish_service.get_recommended_dishes()
        assert result == dishes
        mock_cache.get.assert_called_once()

@pytest.mark.django_db
class TestOrderService:
    """订单服务测试"""
    
    def setup_method(self):
        self.order_service = OrderService()
        self.user = UserFactory()
    
    def test_create_order_success(self):
        """测试成功创建订单"""
        dish = DishFactory(price=Decimal('25.00'), stock_quantity=10)
        order_data = {
            'cart_items': [
                {
                    'dish_id': dish.id,
                    'quantity': 2,
                    'special_requests': '不要辣'
                }
            ],
            'table_number': 'A01',
            'customer_notes': '快点上菜'
        }
        
        order = self.order_service.create_order(self.user, order_data)
        
        assert order is not None
        assert order.user == self.user
        assert order.total_amount == Decimal('50.00')
        assert order.items.count() == 1
        assert order.table_number == 'A01'
    
    def test_create_order_empty_cart(self):
        """测试空购物车创建订单"""
        order_data = {
            'cart_items': [],
        }
        
        with pytest.raises(ValueError, match="购物车不能为空"):
            self.order_service.create_order(self.user, order_data)
    
    def test_create_order_dish_not_exists(self):
        """测试不存在的菜品"""
        order_data = {
            'cart_items': [
                {
                    'dish_id': 99999,
                    'quantity': 1
                }
            ]
        }
        
        with pytest.raises(ValueError, match="菜品.*不存在或已下架"):
            self.order_service.create_order(self.user, order_data)
    
    def test_create_order_insufficient_stock(self):
        """测试库存不足"""
        dish = DishFactory(stock_quantity=1)
        order_data = {
            'cart_items': [
                {
                    'dish_id': dish.id,
                    'quantity': 5
                }
            ]
        }
        
        with pytest.raises(ValueError, match="库存不足"):
            self.order_service.create_order(self.user, order_data)
    
    def test_cancel_order_success(self):
        """测试成功取消订单"""
        order = OrderFactory(user=self.user, status='pending_payment')
        
        result = self.order_service.cancel_order(order, self.user, "不想要了")
        
        assert result.status == 'cancelled'
        assert result.cancelled_time is not None
    
    def test_cancel_order_permission_denied(self):
        """测试取消他人订单"""
        other_user = UserFactory()
        order = OrderFactory(user=other_user, status='pending_payment')
        
        with pytest.raises(PermissionError, match="只能取消自己的订单"):
            self.order_service.cancel_order(order, self.user)
```

## 5. API测试

### 5.1 API测试基类
**tests/test_api_base.py**：
```python
import pytest
from rest_framework.test import APIClient
from rest_framework import status
from django.contrib.auth import get_user_model
from apps.common.jwt_utils import generate_jwt_token
from tests.factories import UserFactory, AdminUserFactory

User = get_user_model()

@pytest.mark.django_db
class APITestCase:
    """API测试基类"""
    
    def setup_method(self):
        self.client = APIClient()
        self.user = UserFactory()
        self.admin_user = AdminUserFactory()
        
        # 生成token
        self.user_token = generate_jwt_token(self.user)
        self.admin_token = generate_jwt_token(self.admin_user)
    
    def authenticate_user(self):
        """普通用户认证"""
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {self.user_token}')
    
    def authenticate_admin(self):
        """管理员认证"""
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {self.admin_token}')
    
    def clear_credentials(self):
        """清除认证"""
        self.client.credentials()
```

### 5.2 菜品API测试
**tests/test_api_dishes.py**：
```python
import pytest
from rest_framework import status
from django.urls import reverse
from tests.test_api_base import APITestCase
from tests.factories import CategoryFactory, DishFactory

class TestDishAPI(APITestCase):
    """菜品API测试"""
    
    def test_list_dishes_anonymous(self):
        """测试匿名用户获取菜品列表"""
        DishFactory.create_batch(3)
        
        url = reverse('dishes:dishes-list')
        response = self.client.get(url)
        
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
    
    def test_list_dishes_authenticated(self):
        """测试认证用户获取菜品列表"""
        dishes = DishFactory.create_batch(3)
        self.authenticate_user()
        
        url = reverse('dishes:dishes-list')
        response = self.client.get(url)
        
        assert response.status_code == status.HTTP_200_OK
        assert response.data['code'] == 200
        assert len(response.data['data']['results']) == 3
    
    def test_retrieve_dish(self):
        """测试获取菜品详情"""
        dish = DishFactory()
        self.authenticate_user()
        
        url = reverse('dishes:dishes-detail', kwargs={'pk': dish.id})
        response = self.client.get(url)
        
        assert response.status_code == status.HTTP_200_OK
        assert response.data['data']['dish']['name'] == dish.name
    
    def test_create_dish_user_forbidden(self):
        """测试普通用户创建菜品被禁止"""
        category = CategoryFactory()
        self.authenticate_user()
        
        url = reverse('dishes:dishes-list')
        data = {
            'category': category.id,
            'name': '测试菜品',
            'price': '25.00',
            'description': '测试描述'
        }
        response = self.client.post(url, data)
        
        assert response.status_code == status.HTTP_403_FORBIDDEN
    
    def test_create_dish_admin_success(self):
        """测试管理员创建菜品成功"""
        category = CategoryFactory()
        self.authenticate_admin()
        
        url = reverse('dishes:dishes-list')
        data = {
            'category': category.id,
            'name': '测试菜品',
            'price': '25.00',
            'description': '测试描述',
            'stock_quantity': 50
        }
        response = self.client.post(url, data)
        
        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['data']['name'] == '测试菜品'
    
    def test_create_dish_invalid_data(self):
        """测试创建菜品数据验证"""
        category = CategoryFactory()
        self.authenticate_admin()
        
        url = reverse('dishes:dishes-list')
        data = {
            'category': category.id,
            'name': '',  # 无效的名称
            'price': '-5.00',  # 无效的价格
        }
        response = self.client.post(url, data)
        
        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert 'errors' in response.data
    
    def test_search_dishes(self):
        """测试搜索菜品"""
        DishFactory(name="宫保鸡丁")
        DishFactory(name="麻婆豆腐")
        DishFactory(name="红烧肉")
        self.authenticate_user()
        
        url = reverse('dishes:dishes-list')
        response = self.client.get(url, {'search': '宫保'})
        
        assert response.status_code == status.HTTP_200_OK
        results = response.data['data']['results']
        assert len(results) == 1
        assert results[0]['name'] == "宫保鸡丁"
    
    def test_filter_dishes_by_category(self):
        """测试按分类过滤菜品"""
        category1 = CategoryFactory(name="热菜")
        category2 = CategoryFactory(name="凉菜")
        
        DishFactory(category=category1)
        DishFactory(category=category1)
        DishFactory(category=category2)
        
        self.authenticate_user()
        
        url = reverse('dishes:dishes-list')
        response = self.client.get(url, {'category': category1.id})
        
        assert response.status_code == status.HTTP_200_OK
        results = response.data['data']['results']
        assert len(results) == 2
        for dish in results:
            assert dish['category_name'] == "热菜"
    
    def test_get_recommended_dishes(self):
        """测试获取推荐菜品"""
        DishFactory(is_recommended=True)
        DishFactory(is_recommended=True)
        DishFactory(is_recommended=False)
        
        self.authenticate_user()
        
        url = reverse('dishes:dishes-recommended')
        response = self.client.get(url)
        
        assert response.status_code == status.HTTP_200_OK
        assert len(response.data['data']) == 2
```

### 5.3 订单API测试
**tests/test_api_orders.py**：
```python
import pytest
from rest_framework import status
from django.urls import reverse
from tests.test_api_base import APITestCase
from tests.factories import DishFactory, OrderFactory, OrderItemFactory

class TestOrderAPI(APITestCase):
    """订单API测试"""
    
    def test_create_order_success(self):
        """测试成功创建订单"""
        dish = DishFactory(price=25.00, stock_quantity=10)
        self.authenticate_user()
        
        url = reverse('orders:orders-list')
        data = {
            'cart_items': [
                {
                    'dish_id': dish.id,
                    'quantity': 2,
                    'special_requests': '不要辣'
                }
            ],
            'table_number': 'A01',
            'customer_notes': '快点上菜'
        }
        response = self.client.post(url, data, format='json')
        
        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['data']['total_amount'] == '50.00'
        assert response.data['data']['table_number'] == 'A01'
    
    def test_create_order_empty_cart(self):
        """测试空购物车创建订单失败"""
        self.authenticate_user()
        
        url = reverse('orders:orders-list')
        data = {
            'cart_items': []
        }
        response = self.client.post(url, data, format='json')
        
        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert '购物车不能为空' in response.data['message']
    
    def test_get_my_orders(self):
        """测试获取我的订单"""
        # 创建当前用户的订单
        my_orders = OrderFactory.create_batch(2, user=self.user)
        # 创建其他用户的订单
        OrderFactory()
        
        self.authenticate_user()
        
        url = reverse('orders:orders-my_orders')
        response = self.client.get(url)
        
        assert response.status_code == status.HTTP_200_OK
        assert len(response.data['data']['orders']) == 2
    
    def test_get_order_detail_owner(self):
        """测试订单所有者获取订单详情"""
        order = OrderFactory(user=self.user)
        OrderItemFactory(order=order)
        
        self.authenticate_user()
        
        url = reverse('orders:orders-detail', kwargs={'pk': order.id})
        response = self.client.get(url)
        
        assert response.status_code == status.HTTP_200_OK
        assert response.data['data']['order_no'] == order.order_no
        assert len(response.data['data']['items']) == 1
    
    def test_get_order_detail_not_owner(self):
        """测试非订单所有者无法获取订单详情"""
        other_order = OrderFactory()  # 其他用户的订单
        
        self.authenticate_user()
        
        url = reverse('orders:orders-detail', kwargs={'pk': other_order.id})
        response = self.client.get(url)
        
        assert response.status_code == status.HTTP_403_FORBIDDEN
    
    def test_cancel_order_success(self):
        """测试成功取消订单"""
        order = OrderFactory(user=self.user, status='pending_payment')
        
        self.authenticate_user()
        
        url = reverse('orders:orders-cancel', kwargs={'pk': order.id})
        data = {'reason': '不想要了'}
        response = self.client.post(url, data, format='json')
        
        assert response.status_code == status.HTTP_200_OK
        assert response.data['data']['status'] == 'cancelled'
    
    def test_cancel_order_invalid_status(self):
        """测试取消不可取消状态的订单"""
        order = OrderFactory(user=self.user, status='completed')
        
        self.authenticate_user()
        
        url = reverse('orders:orders-cancel', kwargs={'pk': order.id})
        data = {'reason': '不想要了'}
        response = self.client.post(url, data, format='json')
        
        assert response.status_code == status.HTTP_400_BAD_REQUEST
    
    def test_admin_update_order_status(self):
        """测试管理员更新订单状态"""
        order = OrderFactory(status='paid')
        
        self.authenticate_admin()
        
        url = reverse('orders:orders-update_status', kwargs={'pk': order.id})
        data = {
            'status': 'preparing',
            'notes': '开始制作'
        }
        response = self.client.patch(url, data, format='json')
        
        assert response.status_code == status.HTTP_200_OK
        assert response.data['data']['status'] == 'preparing'
    
    def test_user_cannot_update_order_status(self):
        """测试普通用户无法更新订单状态"""
        order = OrderFactory(user=self.user, status='paid')
        
        self.authenticate_user()
        
        url = reverse('orders:orders-update_status', kwargs={'pk': order.id})
        data = {'status': 'preparing'}
        response = self.client.patch(url, data, format='json')
        
        assert response.status_code == status.HTTP_403_FORBIDDEN
```

## 6. 测试运行和覆盖率

### 6.1 运行测试命令
```bash
# 运行所有测试
python -m pytest

# 运行特定应用的测试
python -m pytest tests/test_api_dishes.py

# 运行带标记的测试
python -m pytest -m unit
python -m pytest -m integration
python -m pytest -m api

# 并行运行测试
python -m pytest -n auto

# 生成覆盖率报告
python -m pytest --cov=apps --cov-report=html

# 只运行失败的测试
python -m pytest --lf
```

### 6.2 持续集成配置
**.github/workflows/test.yml**：
```yaml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: testpass
          MYSQL_DATABASE: test_smart_restaurant
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3
      
      redis:
        image: redis:7
        ports:
          - 6379:6379
        options: --health-cmd="redis-cli ping" --health-interval=10s --health-timeout=5s --health-retries=3
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements/test.txt
    
    - name: Run migrations
      run: |
        python manage.py migrate --settings=smart_restaurant.settings.testing
      env:
        DB_HOST: localhost
        DB_PORT: 3306
        DB_PASSWORD: testpass
        REDIS_HOST: localhost
        REDIS_PORT: 6379
    
    - name: Run tests
      run: |
        python -m pytest --cov=apps --cov-report=xml
      env:
        DJANGO_SETTINGS_MODULE: smart_restaurant.settings.testing
        DB_HOST: localhost
        DB_PORT: 3306
        DB_PASSWORD: testpass
        REDIS_HOST: localhost
        REDIS_PORT: 6379
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
```

## 7. 生产环境部署

### 7.1 生产环境配置
**smart_restaurant/settings/production.py**：
```python
from .base import *
import os

DEBUG = False

# 安全设置
SECRET_KEY = os.getenv('SECRET_KEY')
if not SECRET_KEY:
    raise ValueError("SECRET_KEY environment variable is required")

ALLOWED_HOSTS = os.getenv('ALLOWED_HOSTS', '').split(',')

# 数据库配置
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': os.getenv('DB_NAME'),
        'USER': os.getenv('DB_USER'),
        'PASSWORD': os.getenv('DB_PASSWORD'),
        'HOST': os.getenv('DB_HOST'),
        'PORT': os.getenv('DB_PORT', '3306'),
        'OPTIONS': {
            'charset': 'utf8mb4',
            'init_command': "SET sql_mode='STRICT_TRANS_TABLES'",
            'sql_mode': 'STRICT_TRANS_TABLES',
        },
        'CONN_MAX_AGE': 60,
    }
}

# Redis配置
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': f"redis://{os.getenv('REDIS_HOST')}:{os.getenv('REDIS_PORT', '6379')}/1",
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'CONNECTION_POOL_KWARGS': {
                'max_connections': 100,
                'retry_on_timeout': True,
            },
            'COMPRESSOR': 'django_redis.compressors.zlib.ZlibCompressor',
        },
        'KEY_PREFIX': 'smart_restaurant_prod',
        'TIMEOUT': 300,
    }
}

# 安全设置
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

# HTTPS设置
if os.getenv('USE_HTTPS', 'False').lower() == 'true':
    SECURE_SSL_REDIRECT = True
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')

# 静态文件
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
STATICFILES_STORAGE = 'django.contrib.staticfiles.storage.ManifestStaticFilesStorage'

# 媒体文件（如果使用云存储）
if os.getenv('USE_S3', 'False').lower() == 'true':
    DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'
    AWS_ACCESS_KEY_ID = os.getenv('AWS_ACCESS_KEY_ID')
    AWS_SECRET_ACCESS_KEY = os.getenv('AWS_SECRET_ACCESS_KEY')
    AWS_STORAGE_BUCKET_NAME = os.getenv('AWS_STORAGE_BUCKET_NAME')
    AWS_S3_REGION_NAME = os.getenv('AWS_S3_REGION_NAME', 'us-west-2')

# 日志配置
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/var/log/smart_restaurant/django.log',
            'maxBytes': 1024*1024*15,  # 15MB
            'backupCount': 10,
            'formatter': 'verbose',
        },
        'error_file': {
            'level': 'ERROR',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/var/log/smart_restaurant/error.log',
            'maxBytes': 1024*1024*15,  # 15MB
            'backupCount': 10,
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['file'],
        'level': 'INFO',
    },
    'loggers': {
        'django': {
            'handlers': ['file', 'error_file'],
            'level': 'INFO',
            'propagate': False,
        },
        'smart_restaurant': {
            'handlers': ['file', 'error_file'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}

# Celery配置（生产环境）
CELERY_BROKER_URL = f"redis://{os.getenv('REDIS_HOST')}:{os.getenv('REDIS_PORT', '6379')}/0"
CELERY_RESULT_BACKEND = f"redis://{os.getenv('REDIS_HOST')}:{os.getenv('REDIS_PORT', '6379')}/0"
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TIMEZONE = TIME_ZONE
CELERY_ENABLE_UTC = True

# 监控设置
if os.getenv('SENTRY_DSN'):
    import sentry_sdk
    from sentry_sdk.integrations.django import DjangoIntegration
    from sentry_sdk.integrations.celery import CeleryIntegration
    
    sentry_sdk.init(
        dsn=os.getenv('SENTRY_DSN'),
        integrations=[
            DjangoIntegration(),
            CeleryIntegration(),
        ],
        traces_sample_rate=0.1,
        send_default_pii=True,
        environment='production'
    )
```

### 7.2 Docker配置
**Dockerfile**：
```dockerfile
FROM python:3.11-slim

# 设置环境变量
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
ENV DJANGO_SETTINGS_MODULE=smart_restaurant.settings.production

# 安装系统依赖
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        default-mysql-client \
        gcc \
        default-libmysqlclient-dev \
        pkg-config \
    && rm -rf /var/lib/apt/lists/*

# 设置工作目录
WORKDIR /app

# 复制依赖文件
COPY requirements/ requirements/
RUN pip install --no-cache-dir -r requirements/production.txt

# 复制项目文件
COPY . .

# 创建静态文件目录
RUN mkdir -p /app/staticfiles /app/media /var/log/smart_restaurant

# 收集静态文件
RUN python manage.py collectstatic --noinput

# 创建非root用户
RUN adduser --disabled-password --gecos '' appuser && \
    chown -R appuser:appuser /app /var/log/smart_restaurant
USER appuser

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "--workers", "4", "smart_restaurant.wsgi:application"]
```

**docker-compose.yml**：
```yaml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DEBUG=False
      - SECRET_KEY=${SECRET_KEY}
      - DB_HOST=db
      - DB_NAME=smart_restaurant
      - DB_USER=restaurant_user
      - DB_PASSWORD=${DB_PASSWORD}
      - REDIS_HOST=redis
      - ALLOWED_HOSTS=localhost,127.0.0.1,yourdomain.com
    volumes:
      - static_volume:/app/staticfiles
      - media_volume:/app/media
      - ./logs:/var/log/smart_restaurant
    depends_on:
      - db
      - redis
    restart: unless-stopped

  db:
    image: mysql:8.0
    environment:
      - MYSQL_DATABASE=smart_restaurant
      - MYSQL_USER=restaurant_user
      - MYSQL_PASSWORD=${DB_PASSWORD}
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    restart: unless-stopped

  celery:
    build: .
    command: celery -A smart_restaurant worker -l info
    environment:
      - DEBUG=False
      - SECRET_KEY=${SECRET_KEY}
      - DB_HOST=db
      - DB_NAME=smart_restaurant
      - DB_USER=restaurant_user
      - DB_PASSWORD=${DB_PASSWORD}
      - REDIS_HOST=redis
    volumes:
      - ./logs:/var/log/smart_restaurant
    depends_on:
      - db
      - redis
    restart: unless-stopped

  celery-beat:
    build: .
    command: celery -A smart_restaurant beat -l info
    environment:
      - DEBUG=False
      - SECRET_KEY=${SECRET_KEY}
      - DB_HOST=db
      - DB_NAME=smart_restaurant
      - DB_USER=restaurant_user
      - DB_PASSWORD=${DB_PASSWORD}
      - REDIS_HOST=redis
    volumes:
      - ./logs:/var/log/smart_restaurant
    depends_on:
      - db
      - redis
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - static_volume:/app/staticfiles
      - media_volume:/app/media
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - web
    restart: unless-stopped

volumes:
  mysql_data:
  static_volume:
  media_volume:
```

### 7.3 部署脚本
**deploy.sh**：
```bash
#!/bin/bash

set -e

echo "开始部署智慧餐厅系统..."

# 更新代码
git pull origin main

# 构建Docker镜像
docker-compose build

# 停止旧服务
docker-compose down

# 运行数据库迁移
docker-compose run --rm web python manage.py migrate

# 收集静态文件
docker-compose run --rm web python manage.py collectstatic --noinput

# 启动服务
docker-compose up -d

# 检查服务状态
sleep 10
docker-compose ps

# 运行健康检查
curl -f http://localhost/health/ || exit 1

echo "部署完成！"
```

通过完善的测试体系和自动化部署流程，确保系统的稳定性和可靠性，为用户提供高质量的服务。 