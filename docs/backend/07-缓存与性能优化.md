# 智慧餐厅系统 - 缓存与性能优化

## 1. 缓存策略概述

### 1.1 缓存层级设计
- **L1缓存**：Django本地缓存（内存）
- **L2缓存**：Redis分布式缓存
- **L3缓存**：数据库查询结果缓存
- **L4缓存**：静态文件CDN缓存

### 1.2 缓存使用场景
- 热点菜品数据缓存
- 用户会话信息缓存
- 分类菜单结构缓存
- 订单统计数据缓存
- API接口响应缓存

## 2. Redis缓存配置

### 2.1 Redis连接配置
**settings/base.py中的Redis配置**：
```python
# Redis缓存配置
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': f"redis://{os.getenv('REDIS_HOST', 'localhost')}:{os.getenv('REDIS_PORT', '6379')}/1",
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'CONNECTION_POOL_KWARGS': {
                'max_connections': 50,
                'retry_on_timeout': True,
            },
            'COMPRESSOR': 'django_redis.compressors.zlib.ZlibCompressor',
            'IGNORE_EXCEPTIONS': True,
        },
        'KEY_PREFIX': 'smart_restaurant',
        'VERSION': 1,
        'TIMEOUT': 300,  # 默认5分钟过期
    },
    # 会话缓存
    'session': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': f"redis://{os.getenv('REDIS_HOST', 'localhost')}:{os.getenv('REDIS_PORT', '6379')}/2",
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        },
        'KEY_PREFIX': 'session',
        'TIMEOUT': 86400,  # 24小时
    },
    # 长期缓存
    'long_term': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': f"redis://{os.getenv('REDIS_HOST', 'localhost')}:{os.getenv('REDIS_PORT', '6379')}/3",
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        },
        'KEY_PREFIX': 'long_term',
        'TIMEOUT': 3600,  # 1小时
    }
}

# 会话存储使用Redis
SESSION_ENGINE = 'django.contrib.sessions.backends.cache'
SESSION_CACHE_ALIAS = 'session'
SESSION_COOKIE_AGE = 86400  # 24小时

# 缓存中间件
MIDDLEWARE = [
    'django.middleware.cache.UpdateCacheMiddleware',  # 页面缓存
    # ... 其他中间件 ...
    'django.middleware.cache.FetchFromCacheMiddleware',
] + MIDDLEWARE

# 页面缓存配置
CACHE_MIDDLEWARE_ALIAS = 'default'
CACHE_MIDDLEWARE_SECONDS = 300
CACHE_MIDDLEWARE_KEY_PREFIX = 'page'
```

### 2.2 Redis客户端工具类
**apps/common/cache.py**：
```python
from django.core.cache import cache, caches
from django.conf import settings
from functools import wraps
import json
import logging
import hashlib

logger = logging.getLogger(__name__)

class CacheManager:
    """缓存管理器"""
    
    def __init__(self, cache_alias='default'):
        self.cache = caches[cache_alias]
        self.default_timeout = 300  # 5分钟
    
    def get(self, key, default=None):
        """获取缓存"""
        try:
            return self.cache.get(key, default)
        except Exception as e:
            logger.error(f"获取缓存失败: key={key}, error={e}")
            return default
    
    def set(self, key, value, timeout=None):
        """设置缓存"""
        try:
            timeout = timeout or self.default_timeout
            return self.cache.set(key, value, timeout)
        except Exception as e:
            logger.error(f"设置缓存失败: key={key}, error={e}")
            return False
    
    def delete(self, key):
        """删除缓存"""
        try:
            return self.cache.delete(key)
        except Exception as e:
            logger.error(f"删除缓存失败: key={key}, error={e}")
            return False
    
    def delete_pattern(self, pattern):
        """批量删除缓存"""
        try:
            return self.cache.delete_pattern(pattern)
        except Exception as e:
            logger.error(f"批量删除缓存失败: pattern={pattern}, error={e}")
            return False
    
    def get_or_set(self, key, callable_func, timeout=None):
        """获取或设置缓存"""
        value = self.get(key)
        if value is None:
            value = callable_func()
            if value is not None:
                self.set(key, value, timeout)
        return value
    
    def increment(self, key, delta=1):
        """递增计数器"""
        try:
            return self.cache.get_or_set(key, 0) + self.cache.incr(key, delta)
        except Exception as e:
            logger.error(f"递增计数器失败: key={key}, error={e}")
            return None
    
    def expire(self, key, timeout):
        """设置过期时间"""
        try:
            return self.cache.expire(key, timeout)
        except Exception as e:
            logger.error(f"设置过期时间失败: key={key}, error={e}")
            return False

# 缓存管理器实例
cache_manager = CacheManager()
long_term_cache = CacheManager('long_term')
session_cache = CacheManager('session')

def cache_key_generator(*args, **kwargs):
    """缓存key生成器"""
    key_parts = []
    for arg in args:
        if hasattr(arg, 'id'):
            key_parts.append(f"{arg.__class__.__name__}_{arg.id}")
        else:
            key_parts.append(str(arg))
    
    for k, v in sorted(kwargs.items()):
        key_parts.append(f"{k}_{v}")
    
    key_string = ":".join(key_parts)
    
    # 如果key太长，使用hash
    if len(key_string) > 200:
        key_string = hashlib.md5(key_string.encode()).hexdigest()
    
    return key_string

def cache_result(timeout=300, cache_alias='default'):
    """缓存函数结果装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 生成缓存key
            cache_key = f"func:{func.__name__}:{cache_key_generator(*args, **kwargs)}"
            
            # 尝试从缓存获取
            cache_instance = caches[cache_alias]
            result = cache_instance.get(cache_key)
            
            if result is None:
                # 执行函数
                result = func(*args, **kwargs)
                # 存入缓存
                if result is not None:
                    cache_instance.set(cache_key, result, timeout)
            
            return result
        return wrapper
    return decorator

def cache_page_with_user(timeout=300):
    """根据用户缓存页面响应"""
    def decorator(view_func):
        @wraps(view_func)
        def wrapper(request, *args, **kwargs):
            # 生成用户相关的缓存key
            user_id = getattr(request.user, 'id', 'anonymous')
            cache_key = f"page:{view_func.__name__}:user_{user_id}:{cache_key_generator(*args, **kwargs)}"
            
            response = cache.get(cache_key)
            if response is None:
                response = view_func(request, *args, **kwargs)
                if response.status_code == 200:
                    cache.set(cache_key, response, timeout)
            
            return response
        return wrapper
    return decorator
```

## 3. 业务数据缓存策略

### 3.1 菜品数据缓存
**apps/dishes/cache.py**：
```python
from apps.common.cache import cache_manager, long_term_cache, cache_result
from django.core.cache import cache
from .models import Category, Dish

class DishCacheService:
    """菜品缓存服务"""
    
    @staticmethod
    @cache_result(timeout=900)  # 15分钟
    def get_categories_with_dishes():
        """获取分类及菜品数据（缓存版本）"""
        categories = Category.objects.filter(is_active=True).prefetch_related(
            'dishes'
        ).order_by('-sort_order')
        
        result = []
        for category in categories:
            active_dishes = category.dishes.filter(is_active=True).order_by(
                '-sort_order', '-sales_count'
            )
            if active_dishes.exists():
                result.append({
                    'category_id': category.id,
                    'category_name': category.name,
                    'category_image': category.image_url,
                    'dishes': [
                        {
                            'id': dish.id,
                            'name': dish.name,
                            'price': float(dish.price),
                            'image_url': dish.image_url,
                            'is_recommended': dish.is_recommended,
                            'sales_count': dish.sales_count,
                            'is_in_stock': dish.is_in_stock(),
                        }
                        for dish in active_dishes
                    ]
                })
        
        return result
    
    @staticmethod
    def get_dish_detail(dish_id):
        """获取菜品详情（缓存版本）"""
        cache_key = f"dish_detail:{dish_id}"
        result = cache_manager.get(cache_key)
        
        if result is None:
            try:
                dish = Dish.objects.select_related('category').get(
                    id=dish_id, is_active=True
                )
                
                # 获取评价统计
                from apps.reviews.models import Review
                from django.db.models import Avg, Count
                
                review_stats = Review.objects.filter(
                    dish=dish, is_visible=True
                ).aggregate(
                    avg_rating=Avg('rating'),
                    total_reviews=Count('id')
                )
                
                result = {
                    'dish': {
                        'id': dish.id,
                        'name': dish.name,
                        'description': dish.description,
                        'price': float(dish.price),
                        'original_price': float(dish.original_price) if dish.original_price else None,
                        'image_url': dish.image_url,
                        'image_urls': dish.image_urls,
                        'category_name': dish.category.name,
                        'spicy_level': dish.spicy_level,
                        'tags': dish.tags,
                        'nutritional_info': dish.nutritional_info,
                        'is_in_stock': dish.is_in_stock(),
                        'sales_count': dish.sales_count,
                    },
                    'avg_rating': round(review_stats['avg_rating'] or 0, 1),
                    'total_reviews': review_stats['total_reviews'] or 0
                }
                
                # 缓存10分钟
                cache_manager.set(cache_key, result, 600)
                
            except Dish.DoesNotExist:
                result = None
        
        return result
    
    @staticmethod
    @cache_result(timeout=1200)  # 20分钟
    def get_recommended_dishes(limit=10):
        """获取推荐菜品（缓存版本）"""
        dishes = Dish.objects.filter(
            is_active=True,
            is_recommended=True
        ).select_related('category').order_by('-sort_order', '-sales_count')[:limit]
        
        return [
            {
                'id': dish.id,
                'name': dish.name,
                'price': float(dish.price),
                'image_url': dish.image_url,
                'category_name': dish.category.name,
                'sales_count': dish.sales_count,
                'is_in_stock': dish.is_in_stock(),
            }
            for dish in dishes
        ]
    
    @staticmethod
    def clear_dish_cache(dish_id=None):
        """清除菜品相关缓存"""
        if dish_id:
            cache_manager.delete(f"dish_detail:{dish_id}")
        
        # 清除列表缓存
        cache_manager.delete_pattern("func:get_categories_with_dishes:*")
        cache_manager.delete_pattern("func:get_recommended_dishes:*")
        cache_manager.delete("categories_with_dishes")
    
    @staticmethod
    def warm_up_cache():
        """预热缓存"""
        # 预热分类菜品数据
        DishCacheService.get_categories_with_dishes()
        
        # 预热推荐菜品
        DishCacheService.get_recommended_dishes()
        
        # 预热热门菜品详情
        hot_dishes = Dish.objects.filter(
            is_active=True
        ).order_by('-sales_count')[:20]
        
        for dish in hot_dishes:
            DishCacheService.get_dish_detail(dish.id)
```

### 3.2 用户数据缓存
**apps/users/cache.py**：
```python
from apps.common.cache import cache_manager, session_cache
from django.contrib.auth import get_user_model

User = get_user_model()

class UserCacheService:
    """用户缓存服务"""
    
    @staticmethod
    def cache_user_profile(user):
        """缓存用户信息"""
        cache_key = f"user_profile:{user.id}"
        
        profile_data = {
            'id': user.id,
            'openid': user.openid,
            'nickname': user.nickname,
            'avatar_url': user.avatar_url,
            'phone': user.phone,
            'gender': user.gender,
            'is_admin': user.is_admin,
            'last_login_time': user.last_login_time.isoformat() if user.last_login_time else None,
            'created_time': user.created_time.isoformat(),
        }
        
        # 缓存30分钟
        cache_manager.set(cache_key, profile_data, 1800)
        return profile_data
    
    @staticmethod
    def get_user_profile(user_id):
        """获取用户信息（缓存版本）"""
        cache_key = f"user_profile:{user_id}"
        profile_data = cache_manager.get(cache_key)
        
        if profile_data is None:
            try:
                user = User.objects.get(id=user_id)
                profile_data = UserCacheService.cache_user_profile(user)
            except User.DoesNotExist:
                return None
        
        return profile_data
    
    @staticmethod
    def cache_user_session(user, token):
        """缓存用户会话"""
        session_key = f"user_session:{user.id}"
        session_data = {
            'user_id': user.id,
            'token': token,
            'login_time': user.last_login_time.isoformat() if user.last_login_time else None,
        }
        
        # 会话缓存7天
        session_cache.set(session_key, session_data, 604800)
    
    @staticmethod
    def get_user_session(user_id):
        """获取用户会话"""
        session_key = f"user_session:{user_id}"
        return session_cache.get(session_key)
    
    @staticmethod
    def clear_user_cache(user_id):
        """清除用户缓存"""
        cache_manager.delete(f"user_profile:{user_id}")
        session_cache.delete(f"user_session:{user_id}")
```

### 3.3 订单统计缓存
**apps/orders/cache.py**：
```python
from apps.common.cache import cache_manager, long_term_cache
from django.db.models import Count, Sum, Avg
from django.utils import timezone
from datetime import datetime, timedelta
from .models import Order

class OrderCacheService:
    """订单缓存服务"""
    
    @staticmethod
    def get_order_statistics(date_range=None, force_refresh=False):
        """获取订单统计（缓存版本）"""
        # 生成缓存key
        if date_range:
            start_date, end_date = date_range
            cache_key = f"order_stats:{start_date}_{end_date}"
        else:
            cache_key = "order_stats:all_time"
        
        if not force_refresh:
            stats = long_term_cache.get(cache_key)
            if stats:
                return stats
        
        # 查询数据库
        queryset = Order.objects.all()
        if date_range:
            queryset = queryset.filter(created_time__range=date_range)
        
        stats = queryset.aggregate(
            total_orders=Count('id'),
            total_amount=Sum('final_amount'),
            avg_amount=Avg('final_amount'),
            pending_orders=Count('id', filter=models.Q(status='pending_payment')),
            completed_orders=Count('id', filter=models.Q(status='completed')),
            cancelled_orders=Count('id', filter=models.Q(status='cancelled'))
        )
        
        # 处理None值
        for key, value in stats.items():
            if value is None:
                stats[key] = 0
        
        # 缓存30分钟
        long_term_cache.set(cache_key, stats, 1800)
        return stats
    
    @staticmethod
    def get_daily_order_trend(days=7):
        """获取每日订单趋势（缓存版本）"""
        cache_key = f"daily_order_trend:{days}days"
        trend_data = long_term_cache.get(cache_key)
        
        if trend_data is None:
            end_date = timezone.now().date()
            start_date = end_date - timedelta(days=days-1)
            
            trend_data = []
            current_date = start_date
            
            while current_date <= end_date:
                day_orders = Order.objects.filter(
                    created_time__date=current_date
                ).aggregate(
                    count=Count('id'),
                    amount=Sum('final_amount')
                )
                
                trend_data.append({
                    'date': current_date.isoformat(),
                    'order_count': day_orders['count'] or 0,
                    'total_amount': float(day_orders['amount'] or 0)
                })
                
                current_date += timedelta(days=1)
            
            # 缓存1小时
            long_term_cache.set(cache_key, trend_data, 3600)
        
        return trend_data
    
    @staticmethod
    def get_popular_dishes(limit=10):
        """获取热门菜品（缓存版本）"""
        cache_key = f"popular_dishes:top_{limit}"
        popular_dishes = long_term_cache.get(cache_key)
        
        if popular_dishes is None:
            from apps.orders.models import OrderItem
            from django.db.models import Sum
            
            # 统计最近30天的销售数据
            thirty_days_ago = timezone.now() - timedelta(days=30)
            
            popular_dishes = OrderItem.objects.filter(
                order__created_time__gte=thirty_days_ago,
                order__status__in=['paid', 'preparing', 'ready', 'completed']
            ).values(
                'dish_id', 'dish_name'
            ).annotate(
                total_quantity=Sum('quantity'),
                total_amount=Sum('subtotal')
            ).order_by('-total_quantity')[:limit]
            
            popular_dishes = list(popular_dishes)
            
            # 缓存2小时
            long_term_cache.set(cache_key, popular_dishes, 7200)
        
        return popular_dishes
    
    @staticmethod
    def clear_order_statistics_cache():
        """清除订单统计缓存"""
        long_term_cache.delete_pattern("order_stats:*")
        long_term_cache.delete_pattern("daily_order_trend:*")
        long_term_cache.delete_pattern("popular_dishes:*")
```

## 4. 数据库查询优化

### 4.1 查询优化基类
**apps/common/querysets.py**：
```python
from django.db import models
from django.db.models import Prefetch

class OptimizedQuerySetMixin:
    """查询优化混入类"""
    
    def with_select_related(self, *fields):
        """使用select_related优化外键查询"""
        return self.select_related(*fields)
    
    def with_prefetch_related(self, *lookups):
        """使用prefetch_related优化反向外键查询"""
        return self.prefetch_related(*lookups)
    
    def active_only(self):
        """只查询激活的记录"""
        return self.filter(is_active=True)
    
    def with_annotations(self, **annotations):
        """添加注解"""
        return self.annotate(**annotations)

class OptimizedManager(models.Manager):
    """优化的管理器"""
    
    def get_queryset(self):
        return super().get_queryset()
    
    def active(self):
        """获取激活的记录"""
        return self.get_queryset().filter(is_active=True)
    
    def with_related(self, *related_fields):
        """预加载关联数据"""
        return self.get_queryset().select_related(*related_fields)
```

### 4.2 菜品查询优化
**apps/dishes/managers.py**：
```python
from django.db import models
from django.db.models import Avg, Count, Q
from apps.common.querysets import OptimizedManager

class CategoryManager(OptimizedManager):
    """分类管理器"""
    
    def with_active_dishes(self):
        """包含激活菜品的分类"""
        return self.active().prefetch_related(
            models.Prefetch(
                'dishes',
                queryset=Dish.objects.filter(is_active=True).order_by('-sort_order', '-sales_count')
            )
        ).order_by('-sort_order')

class DishManager(OptimizedManager):
    """菜品管理器"""
    
    def with_category(self):
        """包含分类信息"""
        return self.select_related('category')
    
    def with_review_stats(self):
        """包含评价统计"""
        from apps.reviews.models import Review
        return self.annotate(
            avg_rating=Avg('reviews__rating', filter=Q(reviews__is_visible=True)),
            review_count=Count('reviews', filter=Q(reviews__is_visible=True))
        )
    
    def recommended(self):
        """推荐菜品"""
        return self.active().filter(is_recommended=True).order_by('-sort_order', '-sales_count')
    
    def by_category(self, category_id):
        """按分类查询"""
        return self.active().filter(category_id=category_id)
    
    def search(self, keyword):
        """搜索菜品"""
        return self.active().filter(
            Q(name__icontains=keyword) |
            Q(description__icontains=keyword) |
            Q(tags__icontains=keyword)
        )
    
    def in_stock(self):
        """有库存的菜品"""
        return self.active().filter(
            Q(stock_quantity__gt=0) | Q(stock_quantity=-1)
        )
    
    def hot_dishes(self, limit=20):
        """热门菜品"""
        return self.active().order_by('-sales_count')[:limit]

# 在模型中使用
class Category(models.Model):
    # ... 字段定义 ...
    objects = CategoryManager()

class Dish(models.Model):
    # ... 字段定义 ...
    objects = DishManager()
```

### 4.3 订单查询优化
**apps/orders/managers.py**：
```python
from django.db import models
from django.db.models import Prefetch, Count, Sum
from apps.common.querysets import OptimizedManager

class OrderManager(OptimizedManager):
    """订单管理器"""
    
    def with_items_and_dishes(self):
        """包含订单项和菜品信息"""
        return self.prefetch_related(
            Prefetch(
                'items',
                queryset=OrderItem.objects.select_related('dish__category')
            )
        )
    
    def with_user_info(self):
        """包含用户信息"""
        return self.select_related('user')
    
    def with_payment_info(self):
        """包含支付信息"""
        return self.prefetch_related('payments')
    
    def with_complete_info(self):
        """包含完整信息"""
        return self.select_related('user', 'coupon').prefetch_related(
            'items__dish__category',
            'payments'
        )
    
    def by_status(self, status):
        """按状态查询"""
        return self.filter(status=status)
    
    def by_user(self, user):
        """按用户查询"""
        return self.filter(user=user)
    
    def recent_orders(self, days=7):
        """最近的订单"""
        from django.utils import timezone
        from datetime import timedelta
        
        since = timezone.now() - timedelta(days=days)
        return self.filter(created_time__gte=since)
    
    def with_statistics(self):
        """包含统计信息"""
        return self.annotate(
            item_count=Count('items'),
            total_quantity=Sum('items__quantity')
        )

class OrderItemManager(OptimizedManager):
    """订单项管理器"""
    
    def with_dish_info(self):
        """包含菜品信息"""
        return self.select_related('dish__category')
    
    def by_dish(self, dish):
        """按菜品查询"""
        return self.filter(dish=dish)

# 在模型中使用
class Order(models.Model):
    # ... 字段定义 ...
    objects = OrderManager()

class OrderItem(models.Model):
    # ... 字段定义 ...
    objects = OrderItemManager()
```

## 5. 视图级缓存优化

### 5.1 API响应缓存
**apps/common/decorators.py**：
```python
from functools import wraps
from django.core.cache import cache
from django.http import JsonResponse
import json
import hashlib

def cache_api_response(timeout=300, cache_key_func=None):
    """API响应缓存装饰器"""
    def decorator(view_func):
        @wraps(view_func)
        def wrapper(request, *args, **kwargs):
            # 生成缓存key
            if cache_key_func:
                cache_key = cache_key_func(request, *args, **kwargs)
            else:
                cache_key = generate_cache_key(view_func.__name__, request, *args, **kwargs)
            
            # 尝试从缓存获取
            cached_response = cache.get(cache_key)
            if cached_response:
                return JsonResponse(cached_response, safe=False)
            
            # 执行视图函数
            response = view_func(request, *args, **kwargs)
            
            # 缓存响应（只缓存成功的响应）
            if hasattr(response, 'data') and response.status_code == 200:
                cache.set(cache_key, response.data, timeout)
            elif isinstance(response, JsonResponse) and response.status_code == 200:
                response_data = json.loads(response.content.decode())
                cache.set(cache_key, response_data, timeout)
            
            return response
        return wrapper
    return decorator

def generate_cache_key(view_name, request, *args, **kwargs):
    """生成缓存key"""
    key_parts = [view_name]
    
    # 添加URL参数
    if args:
        key_parts.extend(map(str, args))
    if kwargs:
        key_parts.extend(f"{k}_{v}" for k, v in sorted(kwargs.items()))
    
    # 添加查询参数
    if request.GET:
        query_params = "&".join(f"{k}={v}" for k, v in sorted(request.GET.items()))
        key_parts.append(query_params)
    
    # 添加用户信息（如果需要）
    if hasattr(request, 'user') and request.user.is_authenticated:
        key_parts.append(f"user_{request.user.id}")
    
    key_string = ":".join(key_parts)
    
    # 如果key太长，使用hash
    if len(key_string) > 200:
        key_string = hashlib.md5(key_string.encode()).hexdigest()
    
    return f"api_response:{key_string}"

def vary_on_user(view_func):
    """根据用户缓存视图"""
    @wraps(view_func)
    def wrapper(request, *args, **kwargs):
        # 添加Vary头，告诉缓存系统这个响应会因用户而异
        response = view_func(request, *args, **kwargs)
        if hasattr(response, '__setitem__'):
            response['Vary'] = 'Authorization'
        return response
    return wrapper
```

### 5.2 使用缓存装饰器的视图
**apps/dishes/views.py（缓存优化版本）**：
```python
from django.views.decorators.cache import cache_page
from django.utils.decorators import method_decorator
from apps.common.decorators import cache_api_response, vary_on_user
from .cache import DishCacheService

class DishViewSet(viewsets.ModelViewSet):
    """菜品视图集（缓存优化版本）"""
    
    @method_decorator(cache_api_response(timeout=600))  # 10分钟缓存
    def list(self, request, *args, **kwargs):
        """获取菜品列表（使用缓存）"""
        # 从缓存服务获取数据
        if not request.query_params:  # 无过滤条件时使用缓存
            data = DishCacheService.get_categories_with_dishes()
            return APIResponse.success(data)
        
        # 有过滤条件时查询数据库
        return super().list(request, *args, **kwargs)
    
    @method_decorator(cache_api_response(timeout=300))  # 5分钟缓存
    def retrieve(self, request, *args, **kwargs):
        """获取菜品详情（使用缓存）"""
        dish_id = kwargs.get('pk')
        data = DishCacheService.get_dish_detail(dish_id)
        
        if not data:
            return APIResponse.not_found("菜品不存在")
        
        return APIResponse.success(data)
    
    @action(detail=False, methods=['get'])
    @method_decorator(cache_api_response(timeout=1200))  # 20分钟缓存
    def recommended(self, request):
        """获取推荐菜品（使用缓存）"""
        data = DishCacheService.get_recommended_dishes()
        return APIResponse.success(data)
```

## 6. 缓存预热和清理

### 6.1 缓存预热任务
**apps/common/tasks.py**：
```python
from celery import shared_task
from apps.dishes.cache import DishCacheService
from apps.orders.cache import OrderCacheService
import logging

logger = logging.getLogger(__name__)

@shared_task
def warm_up_cache():
    """预热缓存"""
    try:
        # 预热菜品数据
        DishCacheService.warm_up_cache()
        
        # 预热订单统计
        OrderCacheService.get_order_statistics()
        OrderCacheService.get_daily_order_trend()
        OrderCacheService.get_popular_dishes()
        
        logger.info("缓存预热完成")
        return "Cache warmed up successfully"
    except Exception as e:
        logger.error(f"缓存预热失败: {e}")
        return f"Cache warm up failed: {e}"

@shared_task
def clear_expired_cache():
    """清理过期缓存"""
    from django.core.cache import cache
    
    try:
        # 这里可以添加特定的缓存清理逻辑
        # Redis会自动清理过期的key，但我们可以主动清理一些不常用的缓存
        
        # 清理旧的统计缓存
        cache.delete_pattern("order_stats:*")
        
        logger.info("过期缓存清理完成")
        return "Expired cache cleared"
    except Exception as e:
        logger.error(f"缓存清理失败: {e}")
        return f"Cache clearing failed: {e}"
```

### 6.2 缓存管理命令
**apps/common/management/commands/cache_management.py**：
```python
from django.core.management.base import BaseCommand
from django.core.cache import cache
from apps.dishes.cache import DishCacheService
from apps.orders.cache import OrderCacheService

class Command(BaseCommand):
    help = '缓存管理命令'

    def add_arguments(self, parser):
        parser.add_argument(
            '--action',
            type=str,
            choices=['warm_up', 'clear', 'stats'],
            help='执行的操作：warm_up(预热), clear(清理), stats(统计)',
        )

    def handle(self, *args, **options):
        action = options['action']
        
        if action == 'warm_up':
            self.warm_up_cache()
        elif action == 'clear':
            self.clear_cache()
        elif action == 'stats':
            self.show_cache_stats()
    
    def warm_up_cache(self):
        """预热缓存"""
        self.stdout.write("开始预热缓存...")
        
        # 预热菜品缓存
        DishCacheService.warm_up_cache()
        self.stdout.write("✓ 菜品数据缓存预热完成")
        
        # 预热订单缓存
        OrderCacheService.get_order_statistics()
        OrderCacheService.get_daily_order_trend()
        self.stdout.write("✓ 订单统计缓存预热完成")
        
        self.stdout.write(
            self.style.SUCCESS("缓存预热完成")
        )
    
    def clear_cache(self):
        """清理缓存"""
        self.stdout.write("开始清理缓存...")
        
        # 清理菜品缓存
        DishCacheService.clear_dish_cache()
        self.stdout.write("✓ 菜品缓存清理完成")
        
        # 清理订单缓存
        OrderCacheService.clear_order_statistics_cache()
        self.stdout.write("✓ 订单统计缓存清理完成")
        
        self.stdout.write(
            self.style.SUCCESS("缓存清理完成")
        )
    
    def show_cache_stats(self):
        """显示缓存统计"""
        self.stdout.write("缓存统计信息:")
        
        # 这里可以添加缓存统计逻辑
        # 例如：key数量、内存使用量等
        
        try:
            from django_redis import get_redis_connection
            redis_conn = get_redis_connection("default")
            
            info = redis_conn.info()
            self.stdout.write(f"Redis内存使用: {info['used_memory_human']}")
            self.stdout.write(f"Redis连接数: {info['connected_clients']}")
            self.stdout.write(f"总key数量: {redis_conn.dbsize()}")
            
        except Exception as e:
            self.stdout.write(f"获取Redis统计失败: {e}")
```

## 7. 性能监控

### 7.1 缓存命中率监控
**apps/common/middleware.py（扩展）**：
```python
import time
from django.core.cache import cache
from django.utils.deprecation import MiddlewareMixin

class CacheStatsMiddleware(MiddlewareMixin):
    """缓存统计中间件"""
    
    def process_request(self, request):
        request._cache_stats = {
            'hits': 0,
            'misses': 0,
            'start_time': time.time()
        }
    
    def process_response(self, request, response):
        if hasattr(request, '_cache_stats'):
            stats = request._cache_stats
            duration = time.time() - stats['start_time']
            
            # 记录到日志或监控系统
            if stats['hits'] + stats['misses'] > 0:
                hit_rate = stats['hits'] / (stats['hits'] + stats['misses'])
                logger.info(f"Cache hit rate: {hit_rate:.2%}, Duration: {duration:.3f}s")
        
        return response

# 自定义缓存类，用于统计
class StatsCache:
    def __init__(self, cache_instance):
        self.cache = cache_instance
    
    def get(self, key, default=None):
        result = self.cache.get(key, default)
        # 记录缓存命中/未命中
        if result is not None:
            self._record_hit()
        else:
            self._record_miss()
        return result
    
    def _record_hit(self):
        # 记录缓存命中
        pass
    
    def _record_miss(self):
        # 记录缓存未命中
        pass
```

通过合理的缓存策略和数据库查询优化，系统性能得到显著提升，为用户提供快速响应的服务体验。 