# 智慧餐厅系统 - 数据模型设计与实现

## 1. Django Models设计原则

### 1.1 设计原则
- 遵循Django的Model最佳实践
- 基于已设计的MySQL数据库表结构
- 合理使用字段类型和约束
- 正确设置模型关系（ForeignKey、ManyToMany等）
- 添加必要的Meta类配置
- 实现__str__方法便于调试

### 1.2 字段类型映射规则

| MySQL类型 | Django字段类型 | 说明 |
|----------|---------------|------|
| BIGINT | BigAutoField/BigIntegerField | 主键使用BigAutoField |
| VARCHAR | CharField | 需要指定max_length |
| TEXT | TextField | 长文本内容 |
| DECIMAL | DecimalField | 需要指定max_digits和decimal_places |
| DATETIME | DateTimeField | 时间字段，设置auto_now等参数 |
| BOOLEAN | BooleanField | 布尔值 |
| TINYINT | IntegerField | 小整数 |
| JSON | JSONField | Django 3.1+支持 |
| ENUM | CharField with choices | 使用choices参数 |

## 2. 公共基类模型

### 2.1 时间戳基类
**apps/common/models.py**：
```python
from django.db import models

class TimeStampedModel(models.Model):
    """时间戳基类模型"""
    created_time = models.DateTimeField('创建时间', auto_now_add=True)
    updated_time = models.DateTimeField('更新时间', auto_now=True)
    
    class Meta:
        abstract = True
```

### 2.2 软删除基类
```python
class SoftDeleteModel(models.Model):
    """软删除基类模型"""
    is_deleted = models.BooleanField('是否删除', default=False)
    deleted_time = models.DateTimeField('删除时间', null=True, blank=True)
    
    class Meta:
        abstract = True
```

## 3. 用户管理模块

### 3.1 用户模型
**apps/users/models.py**：
```python
from django.contrib.auth.models import AbstractUser
from django.db import models
from apps.common.models import TimeStampedModel

class User(AbstractUser, TimeStampedModel):
    """用户模型"""
    
    GENDER_CHOICES = [
        (0, '未知'),
        (1, '男'),
        (2, '女'),
    ]
    
    # 微信相关字段
    openid = models.CharField('微信openid', max_length=100, unique=True, null=True, blank=True)
    union_id = models.CharField('微信unionid', max_length=100, null=True, blank=True)
    nickname = models.CharField('微信昵称', max_length=100, default='微信用户')
    avatar_url = models.URLField('微信头像URL', max_length=500, null=True, blank=True)
    
    # 个人信息
    phone = models.CharField('手机号', max_length=20, null=True, blank=True)
    gender = models.IntegerField('性别', choices=GENDER_CHOICES, default=0)
    
    # 状态字段
    is_active = models.BooleanField('账号是否激活', default=True)
    is_admin = models.BooleanField('是否为管理员', default=False)
    last_login_time = models.DateTimeField('最后登录时间', null=True, blank=True)
    
    class Meta:
        db_table = 'users'
        verbose_name = '用户'
        verbose_name_plural = '用户'
        indexes = [
            models.Index(fields=['openid'], name='idx_users_openid'),
            models.Index(fields=['phone'], name='idx_users_phone'),
            models.Index(fields=['created_time'], name='idx_users_created_time'),
        ]
    
    def __str__(self):
        return f"{self.nickname}({self.openid or self.username})"
    
    def save(self, *args, **kwargs):
        # 如果有openid，将其作为username
        if self.openid and not self.username:
            self.username = self.openid
        super().save(*args, **kwargs)
```

## 4. 菜品管理模块

### 4.1 菜品分类模型
**apps/dishes/models.py**：
```python
from django.db import models
from apps.common.models import TimeStampedModel

class Category(TimeStampedModel):
    """菜品分类模型"""
    name = models.CharField('分类名称', max_length=50)
    description = models.TextField('分类描述', null=True, blank=True)
    image_url = models.URLField('分类图片URL', max_length=500, null=True, blank=True)
    sort_order = models.IntegerField('排序权重', default=0, help_text='数值越大越靠前')
    is_active = models.BooleanField('是否启用', default=True)
    
    class Meta:
        db_table = 'categories'
        verbose_name = '菜品分类'
        verbose_name_plural = '菜品分类'
        ordering = ['-sort_order', 'id']
        indexes = [
            models.Index(fields=['-sort_order'], name='idx_categories_sort_order'),
            models.Index(fields=['is_active'], name='idx_categories_is_active'),
        ]
    
    def __str__(self):
        return self.name

class Dish(TimeStampedModel):
    """菜品模型"""
    
    SPICY_LEVEL_CHOICES = [
        (0, '不辣'),
        (1, '微辣'),
        (2, '中辣'),
        (3, '重辣'),
    ]
    
    category = models.ForeignKey(
        Category, 
        on_delete=models.RESTRICT, 
        verbose_name='所属分类',
        related_name='dishes'
    )
    name = models.CharField('菜品名称', max_length=100)
    description = models.TextField('菜品描述', null=True, blank=True)
    price = models.DecimalField('价格', max_digits=10, decimal_places=2)
    original_price = models.DecimalField('原价', max_digits=10, decimal_places=2, null=True, blank=True)
    image_url = models.URLField('菜品主图URL', max_length=500, null=True, blank=True)
    image_urls = models.JSONField('菜品多图URLs', default=list, null=True, blank=True)
    
    # 库存和销售
    stock_quantity = models.IntegerField('库存数量', default=0, help_text='-1表示无限库存')
    sales_count = models.IntegerField('销售数量', default=0)
    
    # 标志字段
    is_recommended = models.BooleanField('是否推荐菜品', default=False)
    is_active = models.BooleanField('是否上架', default=True)
    sort_order = models.IntegerField('排序权重', default=0)
    
    # 附加信息
    tags = models.CharField('菜品标签', max_length=200, null=True, blank=True, help_text='逗号分隔')
    nutritional_info = models.JSONField('营养信息', null=True, blank=True)
    spicy_level = models.IntegerField('辣度等级', choices=SPICY_LEVEL_CHOICES, default=0)
    
    class Meta:
        db_table = 'dishes'
        verbose_name = '菜品'
        verbose_name_plural = '菜品'
        ordering = ['-sort_order', '-sales_count', 'id']
        indexes = [
            models.Index(fields=['category'], name='idx_dishes_category_id'),
            models.Index(fields=['is_active'], name='idx_dishes_is_active'),
            models.Index(fields=['is_recommended'], name='idx_dishes_is_recommended'),
            models.Index(fields=['price'], name='idx_dishes_price'),
            models.Index(fields=['-sales_count'], name='idx_dishes_sales_count'),
            models.Index(fields=['-sort_order'], name='idx_dishes_sort_order'),
        ]
    
    def __str__(self):
        return f"{self.name} - ¥{self.price}"
    
    def get_display_price(self):
        """获取显示价格"""
        if self.original_price and self.original_price > self.price:
            return f"¥{self.price} (原价¥{self.original_price})"
        return f"¥{self.price}"
    
    def is_in_stock(self):
        """检查是否有库存"""
        if self.stock_quantity == -1:  # 无限库存
            return True
        return self.stock_quantity > 0
    
    def decrease_stock(self, quantity=1):
        """减少库存"""
        if self.stock_quantity != -1:  # 非无限库存
            if self.stock_quantity >= quantity:
                self.stock_quantity -= quantity
                self.save(update_fields=['stock_quantity'])
                return True
            return False
        return True
    
    def increase_sales(self, quantity=1):
        """增加销量"""
        self.sales_count += quantity
        self.save(update_fields=['sales_count'])
```

## 5. 订单管理模块

### 5.1 订单模型
**apps/orders/models.py**：
```python
from django.db import models
from django.contrib.auth import get_user_model
from apps.common.models import TimeStampedModel
from apps.dishes.models import Dish

User = get_user_model()

class Order(TimeStampedModel):
    """订单模型"""
    
    STATUS_CHOICES = [
        ('pending_payment', '待支付'),
        ('paid', '已支付'),
        ('preparing', '制作中'),
        ('ready', '已完成'),
        ('completed', '已完成'),
        ('cancelled', '已取消'),
    ]
    
    PAYMENT_STATUS_CHOICES = [
        ('unpaid', '未支付'),
        ('paid', '已支付'),
        ('refunded', '已退款'),
        ('partial_refunded', '部分退款'),
    ]
    
    order_no = models.CharField('订单号', max_length=32, unique=True)
    user = models.ForeignKey(
        User, 
        on_delete=models.RESTRICT, 
        verbose_name='下单用户',
        related_name='orders'
    )
    
    # 金额字段
    total_amount = models.DecimalField('订单总金额', max_digits=10, decimal_places=2)
    discount_amount = models.DecimalField('优惠金额', max_digits=10, decimal_places=2, default=0.00)
    final_amount = models.DecimalField('实付金额', max_digits=10, decimal_places=2)
    
    # 状态字段
    status = models.CharField('订单状态', max_length=20, choices=STATUS_CHOICES, default='pending_payment')
    payment_status = models.CharField('支付状态', max_length=20, choices=PAYMENT_STATUS_CHOICES, default='unpaid')
    
    # 餐厅信息
    table_number = models.CharField('桌号', max_length=20, null=True, blank=True)
    
    # 备注信息
    customer_notes = models.TextField('顾客备注', null=True, blank=True)
    admin_notes = models.TextField('管理员备注', null=True, blank=True)
    
    # 时间字段
    estimated_time = models.IntegerField('预估完成时间(分钟)', null=True, blank=True)
    paid_time = models.DateTimeField('支付时间', null=True, blank=True)
    completed_time = models.DateTimeField('完成时间', null=True, blank=True)
    cancelled_time = models.DateTimeField('取消时间', null=True, blank=True)
    
    # 优惠券关联
    coupon = models.ForeignKey(
        'coupons.Coupon',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name='使用的优惠券',
        related_name='orders'
    )
    
    class Meta:
        db_table = 'orders'
        verbose_name = '订单'
        verbose_name_plural = '订单'
        ordering = ['-created_time']
        indexes = [
            models.Index(fields=['order_no'], name='idx_orders_order_no'),
            models.Index(fields=['user'], name='idx_orders_user_id'),
            models.Index(fields=['status'], name='idx_orders_status'),
            models.Index(fields=['payment_status'], name='idx_orders_payment_status'),
            models.Index(fields=['-created_time'], name='idx_orders_created_time'),
            models.Index(fields=['table_number'], name='idx_orders_table_number'),
        ]
    
    def __str__(self):
        return f"订单{self.order_no} - {self.get_status_display()}"
    
    def save(self, *args, **kwargs):
        if not self.order_no:
            self.order_no = self.generate_order_no()
        super().save(*args, **kwargs)
    
    @staticmethod
    def generate_order_no():
        """生成订单号"""
        import time
        import random
        timestamp = str(int(time.time()))
        random_num = str(random.randint(1000, 9999))
        return f"SR{timestamp}{random_num}"
    
    def can_cancel(self):
        """判断是否可以取消"""
        return self.status in ['pending_payment', 'paid']
    
    def can_pay(self):
        """判断是否可以支付"""
        return self.status == 'pending_payment' and self.payment_status == 'unpaid'

class OrderItem(TimeStampedModel):
    """订单项模型"""
    order = models.ForeignKey(
        Order,
        on_delete=models.CASCADE,
        verbose_name='订单',
        related_name='items'
    )
    dish = models.ForeignKey(
        Dish,
        on_delete=models.RESTRICT,
        verbose_name='菜品',
        related_name='order_items'
    )
    
    # 快照字段（防止菜品信息变更影响历史订单）
    dish_name = models.CharField('菜品名称(快照)', max_length=100)
    dish_price = models.DecimalField('菜品单价(快照)', max_digits=10, decimal_places=2)
    dish_image_url = models.URLField('菜品图片(快照)', max_length=500, null=True, blank=True)
    
    quantity = models.IntegerField('购买数量')
    subtotal = models.DecimalField('小计金额', max_digits=10, decimal_places=2)
    special_requests = models.TextField('特殊要求', null=True, blank=True)
    
    class Meta:
        db_table = 'order_items'
        verbose_name = '订单项'
        verbose_name_plural = '订单项'
        indexes = [
            models.Index(fields=['order'], name='idx_order_items_order_id'),
            models.Index(fields=['dish'], name='idx_order_items_dish_id'),
        ]
    
    def __str__(self):
        return f"{self.dish_name} x {self.quantity}"
    
    def save(self, *args, **kwargs):
        # 自动设置快照字段
        if self.dish:
            self.dish_name = self.dish.name
            self.dish_price = self.dish.price
            self.dish_image_url = self.dish.image_url
        
        # 计算小计
        self.subtotal = self.dish_price * self.quantity
        super().save(*args, **kwargs)
```

## 6. 支付模块

### 6.1 支付记录模型
**apps/payments/models.py**：
```python
from django.db import models
from apps.common.models import TimeStampedModel
from apps.orders.models import Order

class Payment(TimeStampedModel):
    """支付记录模型"""
    
    PAYMENT_METHOD_CHOICES = [
        ('wechat_pay', '微信支付'),
        ('alipay', '支付宝'),
        ('cash', '现金'),
    ]
    
    STATUS_CHOICES = [
        ('pending', '待支付'),
        ('success', '支付成功'),
        ('failed', '支付失败'),
        ('cancelled', '已取消'),
        ('refunded', '已退款'),
    ]
    
    order = models.ForeignKey(
        Order,
        on_delete=models.RESTRICT,
        verbose_name='订单',
        related_name='payments'
    )
    payment_no = models.CharField('支付流水号', max_length=64, unique=True)
    payment_method = models.CharField('支付方式', max_length=20, choices=PAYMENT_METHOD_CHOICES)
    amount = models.DecimalField('支付金额', max_digits=10, decimal_places=2)
    status = models.CharField('支付状态', max_length=20, choices=STATUS_CHOICES, default='pending')
    
    # 第三方支付信息
    third_party_transaction_id = models.CharField('第三方交易号', max_length=100, null=True, blank=True)
    prepay_id = models.CharField('预支付交易会话标识', max_length=100, null=True, blank=True)
    notify_data = models.JSONField('支付回调通知数据', null=True, blank=True)
    
    # 退款信息
    refund_amount = models.DecimalField('退款金额', max_digits=10, decimal_places=2, default=0.00)
    refund_reason = models.CharField('退款原因', max_length=200, null=True, blank=True)
    
    # 时间字段
    paid_time = models.DateTimeField('支付完成时间', null=True, blank=True)
    
    class Meta:
        db_table = 'payments'
        verbose_name = '支付记录'
        verbose_name_plural = '支付记录'
        ordering = ['-created_time']
        indexes = [
            models.Index(fields=['order'], name='idx_payments_order_id'),
            models.Index(fields=['payment_no'], name='idx_payments_payment_no'),
            models.Index(fields=['third_party_transaction_id'], name='idx_payments_third_party_transaction_id'),
            models.Index(fields=['status'], name='idx_payments_status'),
            models.Index(fields=['-created_time'], name='idx_payments_created_time'),
        ]
    
    def __str__(self):
        return f"支付{self.payment_no} - {self.get_status_display()}"
    
    def save(self, *args, **kwargs):
        if not self.payment_no:
            self.payment_no = self.generate_payment_no()
        super().save(*args, **kwargs)
    
    @staticmethod
    def generate_payment_no():
        """生成支付流水号"""
        import time
        import random
        timestamp = str(int(time.time()))
        random_num = str(random.randint(100000, 999999))
        return f"PAY{timestamp}{random_num}"
```

## 7. 优惠券模块

### 7.1 优惠券模型
**apps/coupons/models.py**：
```python
from django.db import models
from django.contrib.auth import get_user_model
from apps.common.models import TimeStampedModel

User = get_user_model()

class Coupon(TimeStampedModel):
    """优惠券模型"""
    
    TYPE_CHOICES = [
        ('fixed_amount', '固定金额'),
        ('percentage', '百分比折扣'),
        ('free_shipping', '免运费'),
    ]
    
    name = models.CharField('优惠券名称', max_length=100)
    code = models.CharField('优惠券代码', max_length=50, unique=True)
    type = models.CharField('优惠券类型', max_length=20, choices=TYPE_CHOICES)
    discount_value = models.DecimalField('优惠值', max_digits=10, decimal_places=2)
    min_order_amount = models.DecimalField('最小订单金额', max_digits=10, decimal_places=2, default=0.00)
    max_discount_amount = models.DecimalField('最大优惠金额', max_digits=10, decimal_places=2, null=True, blank=True)
    
    # 数量限制
    total_quantity = models.IntegerField('发放总数量')
    used_quantity = models.IntegerField('已使用数量', default=0)
    per_user_limit = models.IntegerField('每用户限用次数', default=1)
    
    # 时间限制
    start_time = models.DateTimeField('有效期开始时间')
    end_time = models.DateTimeField('有效期结束时间')
    
    is_active = models.BooleanField('是否启用', default=True)
    description = models.TextField('使用说明', null=True, blank=True)
    
    class Meta:
        db_table = 'coupons'
        verbose_name = '优惠券'
        verbose_name_plural = '优惠券'
        indexes = [
            models.Index(fields=['code'], name='idx_coupons_code'),
            models.Index(fields=['type'], name='idx_coupons_type'),
            models.Index(fields=['is_active'], name='idx_coupons_is_active'),
            models.Index(fields=['start_time', 'end_time'], name='idx_coupons_start_end_time'),
        ]
    
    def __str__(self):
        return f"{self.name}({self.code})"
    
    def is_valid(self):
        """检查优惠券是否有效"""
        from django.utils import timezone
        now = timezone.now()
        return (self.is_active and 
                self.start_time <= now <= self.end_time and
                self.used_quantity < self.total_quantity)
    
    def calculate_discount(self, order_amount):
        """计算优惠金额"""
        if not self.is_valid() or order_amount < self.min_order_amount:
            return 0
        
        if self.type == 'fixed_amount':
            return min(self.discount_value, order_amount)
        elif self.type == 'percentage':
            discount = order_amount * (self.discount_value / 100)
            if self.max_discount_amount:
                discount = min(discount, self.max_discount_amount)
            return discount
        return 0

class UserCoupon(TimeStampedModel):
    """用户优惠券关联模型"""
    
    STATUS_CHOICES = [
        ('unused', '未使用'),
        ('used', '已使用'),
        ('expired', '已过期'),
    ]
    
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        verbose_name='用户',
        related_name='user_coupons'
    )
    coupon = models.ForeignKey(
        Coupon,
        on_delete=models.CASCADE,
        verbose_name='优惠券',
        related_name='user_coupons'
    )
    order = models.ForeignKey(
        'orders.Order',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name='使用的订单',
        related_name='used_coupons'
    )
    status = models.CharField('使用状态', max_length=20, choices=STATUS_CHOICES, default='unused')
    received_time = models.DateTimeField('领取时间', auto_now_add=True)
    used_time = models.DateTimeField('使用时间', null=True, blank=True)
    
    class Meta:
        db_table = 'user_coupons'
        verbose_name = '用户优惠券'
        verbose_name_plural = '用户优惠券'
        unique_together = [['user', 'coupon']]
        indexes = [
            models.Index(fields=['user'], name='idx_user_coupons_user_id'),
            models.Index(fields=['coupon'], name='idx_user_coupons_coupon_id'),
            models.Index(fields=['status'], name='idx_user_coupons_status'),
        ]
    
    def __str__(self):
        return f"{self.user.nickname} - {self.coupon.name}"
```

## 8. 评价反馈模块

### 8.1 评价和反馈模型
**apps/reviews/models.py**：
```python
from django.db import models
from django.contrib.auth import get_user_model
from django.core.validators import MinValueValidator, MaxValueValidator
from apps.common.models import TimeStampedModel

User = get_user_model()

class Review(TimeStampedModel):
    """评价模型"""
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        verbose_name='评价用户',
        related_name='reviews'
    )
    order = models.ForeignKey(
        'orders.Order',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        verbose_name='关联订单',
        related_name='reviews'
    )
    dish = models.ForeignKey(
        'dishes.Dish',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        verbose_name='关联菜品',
        related_name='reviews'
    )
    
    rating = models.IntegerField(
        '评分',
        validators=[MinValueValidator(1), MaxValueValidator(5)],
        help_text='1-5星评分'
    )
    content = models.TextField('评价内容', null=True, blank=True)
    images = models.JSONField('评价图片URLs', default=list, null=True, blank=True)
    
    is_anonymous = models.BooleanField('是否匿名评价', default=False)
    is_visible = models.BooleanField('是否显示', default=True)
    helpful_count = models.IntegerField('有用数量', default=0)
    
    # 商家回复
    reply_content = models.TextField('商家回复内容', null=True, blank=True)
    reply_time = models.DateTimeField('回复时间', null=True, blank=True)
    
    class Meta:
        db_table = 'reviews'
        verbose_name = '评价'
        verbose_name_plural = '评价'
        ordering = ['-created_time']
        indexes = [
            models.Index(fields=['user'], name='idx_reviews_user_id'),
            models.Index(fields=['order'], name='idx_reviews_order_id'),
            models.Index(fields=['dish'], name='idx_reviews_dish_id'),
            models.Index(fields=['rating'], name='idx_reviews_rating'),
            models.Index(fields=['is_visible'], name='idx_reviews_is_visible'),
            models.Index(fields=['-created_time'], name='idx_reviews_created_time'),
        ]
        constraints = [
            models.CheckConstraint(
                check=models.Q(order__isnull=False) | models.Q(dish__isnull=False),
                name='review_must_have_order_or_dish'
            ),
        ]
    
    def __str__(self):
        target = self.dish.name if self.dish else f"订单{self.order.order_no}"
        return f"{self.user.nickname}对{target}的评价 - {self.rating}星"

class Feedback(TimeStampedModel):
    """用户反馈模型"""
    
    TYPE_CHOICES = [
        ('suggestion', '建议'),
        ('complaint', '投诉'),
        ('bug_report', '问题反馈'),
        ('feature_request', '功能请求'),
        ('other', '其他'),
    ]
    
    STATUS_CHOICES = [
        ('pending', '待处理'),
        ('processing', '处理中'),
        ('completed', '已完成'),
        ('closed', '已关闭'),
    ]
    
    PRIORITY_CHOICES = [
        ('low', '低'),
        ('medium', '中'),
        ('high', '高'),
        ('urgent', '紧急'),
    ]
    
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        verbose_name='反馈用户',
        related_name='feedbacks'
    )
    type = models.CharField('反馈类型', max_length=20, choices=TYPE_CHOICES, default='suggestion')
    title = models.CharField('反馈标题', max_length=200)
    content = models.TextField('反馈内容')
    contact_info = models.CharField('联系方式', max_length=100, null=True, blank=True)
    images = models.JSONField('反馈图片URLs', default=list, null=True, blank=True)
    
    status = models.CharField('处理状态', max_length=20, choices=STATUS_CHOICES, default='pending')
    priority = models.CharField('优先级', max_length=20, choices=PRIORITY_CHOICES, default='medium')
    
    # 管理员处理
    admin_reply = models.TextField('管理员回复', null=True, blank=True)
    admin = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name='处理的管理员',
        related_name='handled_feedbacks'
    )
    reply_time = models.DateTimeField('回复时间', null=True, blank=True)
    tags = models.CharField('标签', max_length=200, null=True, blank=True, help_text='逗号分隔')
    
    class Meta:
        db_table = 'feedbacks'
        verbose_name = '用户反馈'
        verbose_name_plural = '用户反馈'
        ordering = ['-created_time']
        indexes = [
            models.Index(fields=['user'], name='idx_feedbacks_user_id'),
            models.Index(fields=['type'], name='idx_feedbacks_type'),
            models.Index(fields=['status'], name='idx_feedbacks_status'),
            models.Index(fields=['priority'], name='idx_feedbacks_priority'),
            models.Index(fields=['admin'], name='idx_feedbacks_admin_id'),
            models.Index(fields=['-created_time'], name='idx_feedbacks_created_time'),
        ]
    
    def __str__(self):
        return f"{self.title} - {self.get_status_display()}"
```

## 9. 餐厅信息模块

### 9.1 餐厅信息和系统配置模型
**apps/restaurant/models.py**：
```python
from django.db import models
from apps.common.models import TimeStampedModel

class RestaurantInfo(TimeStampedModel):
    """餐厅信息模型"""
    name = models.CharField('餐厅名称', max_length=100)
    description = models.TextField('餐厅描述', null=True, blank=True)
    phone = models.CharField('联系电话', max_length=20, null=True, blank=True)
    address = models.CharField('餐厅地址', max_length=200, null=True, blank=True)
    business_hours = models.JSONField('营业时间', null=True, blank=True)
    logo_url = models.URLField('餐厅LOGO', max_length=500, null=True, blank=True)
    background_images = models.JSONField('背景图片URLs', default=list, null=True, blank=True)
    announcement = models.TextField('餐厅公告', null=True, blank=True)
    
    service_charge_rate = models.DecimalField('服务费率', max_digits=5, decimal_places=2, default=0.00)
    is_open = models.BooleanField('是否营业中', default=True)
    min_order_amount = models.DecimalField('起送金额', max_digits=10, decimal_places=2, default=0.00)
    table_count = models.IntegerField('餐桌数量', default=0)
    avg_meal_time = models.IntegerField('平均用餐时间(分钟)', default=60)
    
    class Meta:
        db_table = 'restaurant_info'
        verbose_name = '餐厅信息'
        verbose_name_plural = '餐厅信息'
    
    def __str__(self):
        return self.name

class SystemConfig(TimeStampedModel):
    """系统配置模型"""
    
    DATA_TYPE_CHOICES = [
        ('string', '字符串'),
        ('number', '数字'),
        ('boolean', '布尔值'),
        ('json', 'JSON'),
    ]
    
    config_key = models.CharField('配置键', max_length=100, unique=True)
    config_value = models.TextField('配置值', null=True, blank=True)
    description = models.CharField('配置描述', max_length=200, null=True, blank=True)
    data_type = models.CharField('数据类型', max_length=20, choices=DATA_TYPE_CHOICES, default='string')
    is_public = models.BooleanField('是否为公开配置', default=False)
    
    class Meta:
        db_table = 'system_configs'
        verbose_name = '系统配置'
        verbose_name_plural = '系统配置'
        indexes = [
            models.Index(fields=['config_key'], name='idx_system_configs_config_key'),
            models.Index(fields=['is_public'], name='idx_system_configs_is_public'),
        ]
    
    def __str__(self):
        return f"{self.config_key}: {self.config_value}"
    
    def get_value(self):
        """根据数据类型返回正确的值"""
        if self.data_type == 'number':
            try:
                return float(self.config_value) if '.' in self.config_value else int(self.config_value)
            except (ValueError, TypeError):
                return 0
        elif self.data_type == 'boolean':
            return self.config_value.lower() in ['true', '1', 'yes', 'on']
        elif self.data_type == 'json':
            import json
            try:
                return json.loads(self.config_value)
            except (json.JSONDecodeError, TypeError):
                return {}
        return self.config_value
```

## 10. 数据库迁移

### 10.1 创建和执行迁移
```bash
# 创建迁移文件
python manage.py makemigrations users
python manage.py makemigrations dishes
python manage.py makemigrations orders
python manage.py makemigrations payments
python manage.py makemigrations coupons
python manage.py makemigrations reviews
python manage.py makemigrations restaurant

# 执行迁移
python manage.py migrate
```

### 10.2 初始数据创建
**create_initial_data.py**：
```python
# management/commands/create_initial_data.py
from django.core.management.base import BaseCommand
from apps.restaurant.models import RestaurantInfo, SystemConfig
from apps.dishes.models import Category

class Command(BaseCommand):
    help = '创建初始数据'
    
    def handle(self, *args, **options):
        # 创建餐厅信息
        restaurant, created = RestaurantInfo.objects.get_or_create(
            defaults={
                'name': '智慧餐厅',
                'description': '美味佳肴，智能体验',
                'phone': '400-123-4567',
                'is_open': True,
            }
        )
        
        # 创建菜品分类
        categories = [
            {'name': '招牌菜', 'sort_order': 100},
            {'name': '热菜', 'sort_order': 90},
            {'name': '凉菜', 'sort_order': 80},
            {'name': '汤品', 'sort_order': 70},
            {'name': '主食', 'sort_order': 60},
            {'name': '饮品', 'sort_order': 50},
        ]
        
        for cat_data in categories:
            Category.objects.get_or_create(
                name=cat_data['name'],
                defaults=cat_data
            )
        
        # 创建系统配置
        configs = [
            {'config_key': 'order_timeout_minutes', 'config_value': '30', 'description': '订单超时时间（分钟）'},
            {'config_key': 'max_table_number', 'config_value': '50', 'description': '最大桌号'},
            {'config_key': 'service_start_time', 'config_value': '09:00', 'description': '服务开始时间'},
            {'config_key': 'service_end_time', 'config_value': '22:00', 'description': '服务结束时间'},
        ]
        
        for config_data in configs:
            SystemConfig.objects.get_or_create(
                config_key=config_data['config_key'],
                defaults=config_data
            )
        
        self.stdout.write(self.style.SUCCESS('初始数据创建完成'))
```

执行初始数据创建：
```bash
python manage.py create_initial_data
```

至此，数据模型设计完成，为后续的业务逻辑和API接口开发奠定了坚实的基础。 