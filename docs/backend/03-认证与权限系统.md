# 智慧餐厅系统 - 认证与权限系统

## 1. 认证系统架构

### 1.1 认证流程概述
- 微信小程序登录 → 获取openid → 用户注册/登录 → 生成JWT Token → 后续请求携带Token
- 支持普通用户和管理员两种角色
- Token过期自动刷新机制

### 1.2 技术实现要点
- 微信小程序code换取openid
- JWT Token生成和验证
- 自定义认证中间件
- 权限装饰器和类

## 2. 微信小程序登录集成

### 2.1 微信API服务类
**apps/common/wechat.py**：
```python
import requests
import json
from django.conf import settings
from django.core.cache import cache
import logging

logger = logging.getLogger(__name__)

class WeChatMiniProgramService:
    """微信小程序服务类"""
    
    def __init__(self):
        self.app_id = settings.WECHAT_MINIPROGRAM['APP_ID']
        self.app_secret = settings.WECHAT_MINIPROGRAM['APP_SECRET']
        self.code2session_url = 'https://api.weixin.qq.com/sns/jscode2session'
    
    def code_to_session(self, code):
        """
        微信小程序code换取openid和session_key
        """
        params = {
            'appid': self.app_id,
            'secret': self.app_secret,
            'js_code': code,
            'grant_type': 'authorization_code'
        }
        
        try:
            response = requests.get(self.code2session_url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            if 'errcode' in data:
                logger.error(f"微信登录失败: {data}")
                return None, f"微信登录失败: {data.get('errmsg', '未知错误')}"
            
            return data, None
            
        except requests.exceptions.RequestException as e:
            logger.error(f"微信API请求异常: {e}")
            return None, "网络请求失败，请稍后重试"
        except json.JSONDecodeError as e:
            logger.error(f"微信API响应解析失败: {e}")
            return None, "响应数据解析失败"
    
    def decrypt_user_info(self, encrypted_data, iv, session_key):
        """
        解密微信用户信息
        注意：本示例仅供参考，实际项目中需要使用微信官方提供的解密库
        """
        # 这里需要实现AES解密逻辑
        # from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        # 具体实现省略...
        pass
    
    def get_access_token(self):
        """
        获取微信接口调用凭证
        """
        cache_key = f"wechat_access_token_{self.app_id}"
        access_token = cache.get(cache_key)
        
        if access_token:
            return access_token
        
        url = 'https://api.weixin.qq.com/cgi-bin/token'
        params = {
            'grant_type': 'client_credential',
            'appid': self.app_id,
            'secret': self.app_secret
        }
        
        try:
            response = requests.get(url, params=params, timeout=10)
            data = response.json()
            
            if 'access_token' in data:
                access_token = data['access_token']
                expires_in = data.get('expires_in', 7200)
                # 提前5分钟过期
                cache.set(cache_key, access_token, expires_in - 300)
                return access_token
            else:
                logger.error(f"获取access_token失败: {data}")
                return None
                
        except Exception as e:
            logger.error(f"获取access_token异常: {e}")
            return None
```

### 2.2 用户登录业务逻辑
**apps/users/services.py**：
```python
from django.contrib.auth import get_user_model
from django.utils import timezone
from apps.common.wechat import WeChatMiniProgramService
from apps.common.jwt_utils import generate_jwt_token
import logging

User = get_user_model()
logger = logging.getLogger(__name__)

class UserAuthService:
    """用户认证服务类"""
    
    def __init__(self):
        self.wechat_service = WeChatMiniProgramService()
    
    def wechat_login(self, code, user_info=None):
        """
        微信小程序登录
        Args:
            code: 微信登录code
            user_info: 用户信息（可选）
        Returns:
            tuple: (user, token, error_message)
        """
        # 1. 通过code获取openid
        session_data, error = self.wechat_service.code_to_session(code)
        if error:
            return None, None, error
        
        openid = session_data.get('openid')
        session_key = session_data.get('session_key')
        union_id = session_data.get('unionid')
        
        if not openid:
            return None, None, "获取openid失败"
        
        # 2. 查找或创建用户
        user, created = User.objects.get_or_create(
            openid=openid,
            defaults={
                'username': openid,
                'union_id': union_id,
                'is_active': True,
            }
        )
        
        # 3. 更新用户信息
        if user_info and isinstance(user_info, dict):
            user.nickname = user_info.get('nickName', user.nickname)
            user.avatar_url = user_info.get('avatarUrl', user.avatar_url)
            user.gender = user_info.get('gender', user.gender)
        
        user.last_login_time = timezone.now()
        user.save(update_fields=['nickname', 'avatar_url', 'gender', 'last_login_time'])
        
        # 4. 生成JWT Token
        token = generate_jwt_token(user)
        
        logger.info(f"用户登录成功: openid={openid}, created={created}")
        
        return user, token, None
    
    def refresh_token(self, user):
        """刷新用户Token"""
        return generate_jwt_token(user)
    
    def logout(self, token):
        """用户登出"""
        # 将token加入黑名单（如果需要的话）
        # TokenBlacklist.objects.create(token=token)
        pass
```

## 3. JWT Token认证

### 3.1 JWT工具类
**apps/common/jwt_utils.py**：
```python
import jwt
import datetime
from django.conf import settings
from django.contrib.auth import get_user_model
from django.core.cache import cache
import logging

User = get_user_model()
logger = logging.getLogger(__name__)

def generate_jwt_token(user):
    """
    生成JWT Token
    """
    payload = {
        'user_id': user.id,
        'openid': user.openid,
        'is_admin': user.is_admin,
        'exp': datetime.datetime.utcnow() + datetime.timedelta(seconds=settings.JWT_EXP_DELTA_SECONDS),
        'iat': datetime.datetime.utcnow(),
    }
    
    token = jwt.encode(
        payload,
        settings.JWT_SECRET_KEY,
        algorithm=settings.JWT_ALGORITHM
    )
    
    return token

def decode_jwt_token(token):
    """
    解码JWT Token
    """
    try:
        payload = jwt.decode(
            token,
            settings.JWT_SECRET_KEY,
            algorithms=[settings.JWT_ALGORITHM]
        )
        return payload, None
    except jwt.ExpiredSignatureError:
        return None, "Token已过期"
    except jwt.InvalidTokenError as e:
        return None, f"Token无效: {str(e)}"

def get_user_from_token(token):
    """
    从Token获取用户对象
    """
    payload, error = decode_jwt_token(token)
    if error:
        return None, error
    
    try:
        user_id = payload.get('user_id')
        user = User.objects.get(id=user_id, is_active=True)
        return user, None
    except User.DoesNotExist:
        return None, "用户不存在或已被禁用"

def is_token_blacklisted(token):
    """
    检查Token是否在黑名单中
    """
    # 如果使用Redis缓存实现黑名单
    blacklist_key = f"jwt_blacklist:{token}"
    return cache.get(blacklist_key) is not None

def blacklist_token(token):
    """
    将Token加入黑名单
    """
    payload, error = decode_jwt_token(token)
    if not error:
        # 计算剩余过期时间
        exp_timestamp = payload.get('exp', 0)
        current_timestamp = datetime.datetime.utcnow().timestamp()
        remaining_time = int(exp_timestamp - current_timestamp)
        
        if remaining_time > 0:
            blacklist_key = f"jwt_blacklist:{token}"
            cache.set(blacklist_key, True, remaining_time)
```

### 3.2 自定义JWT认证类
**apps/common/authentication.py**：
```python
from rest_framework.authentication import BaseAuthentication
from rest_framework.exceptions import AuthenticationFailed
from django.contrib.auth import get_user_model
from .jwt_utils import get_user_from_token, is_token_blacklisted

User = get_user_model()

class JWTAuthentication(BaseAuthentication):
    """
    自定义JWT认证类
    """
    keyword = 'Bearer'
    
    def authenticate(self, request):
        """
        认证方法
        """
        header = self.get_authorization_header(request)
        if not header:
            return None
        
        token = self.get_token_from_header(header)
        if not token:
            return None
        
        return self.authenticate_credentials(token)
    
    def get_authorization_header(self, request):
        """
        获取Authorization header
        """
        auth_header = request.META.get('HTTP_AUTHORIZATION')
        if not auth_header:
            return None
        
        return auth_header.encode('utf-8')
    
    def get_token_from_header(self, header):
        """
        从header中提取token
        """
        try:
            header = header.decode('utf-8')
        except UnicodeDecodeError:
            return None
        
        parts = header.split()
        
        if len(parts) != 2 or parts[0] != self.keyword:
            return None
        
        return parts[1]
    
    def authenticate_credentials(self, token):
        """
        验证token并返回用户
        """
        # 检查token是否在黑名单中
        if is_token_blacklisted(token):
            raise AuthenticationFailed('Token已失效')
        
        user, error = get_user_from_token(token)
        if error:
            raise AuthenticationFailed(error)
        
        return (user, token)
    
    def authenticate_header(self, request):
        """
        返回WWW-Authenticate header
        """
        return f'{self.keyword} realm="api"'
```

## 4. 权限控制系统

### 4.1 权限检查函数
**apps/common/permissions.py**：
```python
from rest_framework.permissions import BasePermission
from rest_framework.exceptions import PermissionDenied
from functools import wraps
from django.http import JsonResponse

class IsAdminUser(BasePermission):
    """
    管理员权限
    """
    def has_permission(self, request, view):
        return bool(
            request.user and 
            request.user.is_authenticated and 
            request.user.is_admin
        )

class IsOwnerOrAdmin(BasePermission):
    """
    资源所有者或管理员权限
    """
    def has_object_permission(self, request, view, obj):
        # 管理员有所有权限
        if request.user.is_admin:
            return True
        
        # 检查是否为资源所有者
        if hasattr(obj, 'user'):
            return obj.user == request.user
        
        return False

class IsActiveUser(BasePermission):
    """
    活跃用户权限
    """
    def has_permission(self, request, view):
        return bool(
            request.user and
            request.user.is_authenticated and
            request.user.is_active
        )

def require_login(view_func):
    """
    要求登录装饰器
    """
    @wraps(view_func)
    def wrapper(request, *args, **kwargs):
        if not request.user.is_authenticated:
            return JsonResponse({
                'code': 401,
                'message': '请先登录',
                'data': None
            }, status=401)
        return view_func(request, *args, **kwargs)
    return wrapper

def require_admin(view_func):
    """
    要求管理员权限装饰器
    """
    @wraps(view_func)
    def wrapper(request, *args, **kwargs):
        if not request.user.is_authenticated:
            return JsonResponse({
                'code': 401,
                'message': '请先登录',
                'data': None
            }, status=401)
        
        if not request.user.is_admin:
            return JsonResponse({
                'code': 403,
                'message': '需要管理员权限',
                'data': None
            }, status=403)
        
        return view_func(request, *args, **kwargs)
    return wrapper

def check_user_permission(user, permission_name, obj=None):
    """
    检查用户权限
    """
    if not user.is_authenticated:
        return False
    
    if user.is_admin:
        return True
    
    # 根据权限名称进行具体检查
    if permission_name == 'view_order':
        return obj and obj.user == user
    elif permission_name == 'edit_dish':
        return user.is_admin
    elif permission_name == 'manage_restaurant':
        return user.is_admin
    
    return False
```

### 4.2 权限中间件
**apps/common/middleware.py**：
```python
from django.http import JsonResponse
from django.utils.deprecation import MiddlewareMixin
from .authentication import JWTAuthentication
import logging

logger = logging.getLogger(__name__)

class JWTAuthenticationMiddleware(MiddlewareMixin):
    """
    JWT认证中间件
    """
    def __init__(self, get_response):
        self.get_response = get_response
        self.jwt_auth = JWTAuthentication()
        super().__init__(get_response)
    
    def process_request(self, request):
        """
        处理请求，尝试进行JWT认证
        """
        # 跳过不需要认证的路径
        skip_paths = [
            '/api/users/wechat-login/',
            '/api/health/',
            '/admin/',
            '/api/schema/',
        ]
        
        if any(request.path.startswith(path) for path in skip_paths):
            return None
        
        try:
            auth_result = self.jwt_auth.authenticate(request)
            if auth_result:
                request.user, request.auth = auth_result
            else:
                # 未提供认证信息时，设置匿名用户
                from django.contrib.auth.models import AnonymousUser
                request.user = AnonymousUser()
        
        except Exception as e:
            logger.warning(f"JWT认证失败: {e}")
            return JsonResponse({
                'code': 401,
                'message': str(e),
                'data': None
            }, status=401)
        
        return None

class CORSMiddleware(MiddlewareMixin):
    """
    CORS跨域中间件
    """
    def process_response(self, request, response):
        response['Access-Control-Allow-Origin'] = '*'
        response['Access-Control-Allow-Methods'] = 'GET, POST, PUT, PATCH, DELETE, OPTIONS'
        response['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
        response['Access-Control-Max-Age'] = '3600'
        
        if request.method == 'OPTIONS':
            response.status_code = 200
            
        return response
```

## 5. 认证相关API接口

### 5.1 用户认证视图
**apps/users/views.py**：
```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from rest_framework.permissions import AllowAny
from django.contrib.auth import get_user_model
from .services import UserAuthService
from .serializers import UserSerializer, WeChatLoginSerializer
from apps.common.permissions import IsActiveUser
from apps.common.jwt_utils import blacklist_token
import logging

User = get_user_model()
logger = logging.getLogger(__name__)

class WeChatLoginView(APIView):
    """
    微信小程序登录
    """
    permission_classes = [AllowAny]
    
    def post(self, request):
        serializer = WeChatLoginSerializer(data=request.data)
        if not serializer.is_valid():
            return Response({
                'code': 400,
                'message': '参数错误',
                'errors': serializer.errors,
                'data': None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        code = serializer.validated_data['code']
        user_info = serializer.validated_data.get('user_info')
        
        auth_service = UserAuthService()
        user, token, error = auth_service.wechat_login(code, user_info)
        
        if error:
            return Response({
                'code': 400,
                'message': error,
                'data': None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        user_serializer = UserSerializer(user)
        return Response({
            'code': 200,
            'message': '登录成功',
            'data': {
                'user': user_serializer.data,
                'token': token,
                'token_type': 'Bearer'
            }
        })

class UserProfileView(APIView):
    """
    用户个人信息
    """
    permission_classes = [IsActiveUser]
    
    def get(self, request):
        """获取当前用户信息"""
        serializer = UserSerializer(request.user)
        return Response({
            'code': 200,
            'message': '获取成功',
            'data': serializer.data
        })
    
    def put(self, request):
        """更新用户信息"""
        serializer = UserSerializer(request.user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response({
                'code': 200,
                'message': '更新成功',
                'data': serializer.data
            })
        
        return Response({
            'code': 400,
            'message': '参数错误',
            'errors': serializer.errors,
            'data': None
        }, status=status.HTTP_400_BAD_REQUEST)

class LogoutView(APIView):
    """
    用户登出
    """
    permission_classes = [IsActiveUser]
    
    def post(self, request):
        """用户登出"""
        token = request.auth
        if token:
            blacklist_token(token)
        
        return Response({
            'code': 200,
            'message': '登出成功',
            'data': None
        })

class RefreshTokenView(APIView):
    """
    刷新Token
    """
    permission_classes = [IsActiveUser]
    
    def post(self, request):
        """刷新用户Token"""
        auth_service = UserAuthService()
        new_token = auth_service.refresh_token(request.user)
        
        # 将旧token加入黑名单
        old_token = request.auth
        if old_token:
            blacklist_token(old_token)
        
        return Response({
            'code': 200,
            'message': 'Token刷新成功',
            'data': {
                'token': new_token,
                'token_type': 'Bearer'
            }
        })
```

### 5.2 序列化器
**apps/users/serializers.py**：
```python
from rest_framework import serializers
from django.contrib.auth import get_user_model

User = get_user_model()

class WeChatLoginSerializer(serializers.Serializer):
    """微信登录序列化器"""
    code = serializers.CharField(max_length=100, help_text='微信登录code')
    user_info = serializers.DictField(required=False, help_text='用户信息')

class UserSerializer(serializers.ModelSerializer):
    """用户序列化器"""
    
    class Meta:
        model = User
        fields = [
            'id', 'openid', 'nickname', 'avatar_url', 
            'phone', 'gender', 'is_admin', 'last_login_time',
            'created_time'
        ]
        read_only_fields = ['id', 'openid', 'is_admin', 'last_login_time', 'created_time']
    
    def validate_phone(self, value):
        """验证手机号"""
        if value:
            import re
            if not re.match(r'^1[3-9]\d{9}$', value):
                raise serializers.ValidationError('手机号格式不正确')
        return value

class UserListSerializer(serializers.ModelSerializer):
    """用户列表序列化器（管理员使用）"""
    
    class Meta:
        model = User
        fields = [
            'id', 'nickname', 'phone', 'gender', 
            'is_active', 'is_admin', 'last_login_time', 'created_time'
        ]
```

## 6. URL配置

### 6.1 用户认证相关URL
**apps/users/urls.py**：
```python
from django.urls import path
from . import views

app_name = 'users'

urlpatterns = [
    # 认证相关
    path('wechat-login/', views.WeChatLoginView.as_view(), name='wechat-login'),
    path('logout/', views.LogoutView.as_view(), name='logout'),
    path('refresh-token/', views.RefreshTokenView.as_view(), name='refresh-token'),
    
    # 用户信息
    path('me/', views.UserProfileView.as_view(), name='user-profile'),
]
```

## 7. 使用示例

### 7.1 前端小程序登录示例
```javascript
// 微信小程序登录
wx.login({
  success: (res) => {
    if (res.code) {
      // 获取用户信息
      wx.getUserProfile({
        desc: '用于完善用户信息',
        success: (userRes) => {
          // 发送登录请求
          wx.request({
            url: 'https://yourdomain.com/api/users/wechat-login/',
            method: 'POST',
            data: {
              code: res.code,
              user_info: userRes.userInfo
            },
            success: (loginRes) => {
              if (loginRes.data.code === 200) {
                // 保存token
                wx.setStorageSync('token', loginRes.data.data.token);
                // 保存用户信息
                wx.setStorageSync('userInfo', loginRes.data.data.user);
              }
            }
          });
        }
      });
    }
  }
});

// 后续请求携带token
wx.request({
  url: 'https://yourdomain.com/api/dishes/',
  method: 'GET',
  header: {
    'Authorization': `Bearer ${wx.getStorageSync('token')}`
  },
  success: (res) => {
    console.log(res.data);
  }
});
```

### 7.2 API测试示例
```bash
# 1. 微信登录
curl -X POST http://localhost:8000/api/users/wechat-login/ \
  -H "Content-Type: application/json" \
  -d '{"code": "your-wechat-code"}'

# 2. 获取用户信息
curl -X GET http://localhost:8000/api/users/me/ \
  -H "Authorization: Bearer your-jwt-token"

# 3. 刷新Token
curl -X POST http://localhost:8000/api/users/refresh-token/ \
  -H "Authorization: Bearer your-jwt-token"

# 4. 登出
curl -X POST http://localhost:8000/api/users/logout/ \
  -H "Authorization: Bearer your-jwt-token"
```

## 8. 安全注意事项

### 8.1 Token安全
- JWT密钥使用强随机字符串
- Token过期时间不宜过长
- 敏感操作考虑短期Token

### 8.2 接口安全
- 对所有API接口进行适当的权限控制
- 敏感数据传输使用HTTPS
- 实施API频率限制

### 8.3 用户数据保护
- 用户敏感信息加密存储
- 日志中避免记录敏感信息
- 遵循数据最小化原则

认证与权限系统是整个后端的安全基础，确保了用户身份的可靠性和数据访问的安全性。 